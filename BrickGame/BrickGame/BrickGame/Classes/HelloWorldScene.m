//
//  HelloWorldLayer.m
//  BrickGame
//
//  Created by Илья on 13.06.11.
//  Copyright __MyCompanyName__ 2011. All rights reserved.
//

// Import the interfaces
#import "HelloWorldScene.h"
#import "CCTMXLayer.h"
#import "SneakyButton.h"
#import "SneakyButtonSkinnedBase.h"
#import "SimpleAudioEngine.h"
#import "NSData-AES.h"

CCSprite *GameBackground;

// HelloWorld implementation
@implementation HelloWorld
int speed, level, mode, game, selected; //Скорость, уровень, режим, игра, режим программы и количество очков
BOOL brmap[10][20]; //Пиксельная карта
int XBrick, YBrick; //Где находится кирпич
int TotalClearedLines; //Всего стерто линий в тетрисе
int CurrentBrick[2], NextBrick[2]; //Текущий и следующий кирпич
int score;
int x=0, y=0, z=0, timer=60, pausetimer=60; //Глобальные переменные
int StartButtonPushed=0, RotateButtonPushed=0, LeftButtonPushed=0, RightButtonPushed=0, DownButtonPushed=0, UpButtonPushed=0; //Нажатые кнопки
int PrevBrick[2];
int XBrickPrev, YBrickPrev; //Где раньше находился кирпич
int YBrickLastLine=0; //Сколько времени находится кирпич на последней линии
int NewBrickLineTimer=0, LastLineCleared=0; //Когда появляется новая линия и когда последняя линия была стерта
int LetterAnimation=0, MiniAnimation=0; //Анимации
int trmap[10][20];
int BulletTime;
BOOL next[4][4];
BOOL tScreens[20][10] =
{
	{0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,0,1,1,1,0,0},
	{0,1,0,1,0,1,0,1,0,0},
	{0,1,1,1,0,1,1,1,0,0},
	{0,0,0,1,0,0,0,1,0,0},
	{0,1,1,1,0,1,1,1,0,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,1,1,1,0,1,1,1,0},
	{0,0,1,0,1,0,1,0,1,0},
	{0,0,1,1,1,0,1,1,1,0},
	{0,0,0,0,1,0,0,0,1,0},
	{0,0,1,1,1,0,1,1,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,1,0,0,0,0,0,0,1,0},
	{0,0,0,1,1,0,0,1,1,0},
	{0,1,0,1,0,1,0,0,1,0},
	{0,1,0,1,0,1,0,0,1,0},
	{0,1,0,1,0,1,0,0,1,0},
	{0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0}
};
BOOL mLetters[5][5][5][5] = 
{
	{ //A
		{
			{0,1,1,1,0},
			{1,0,0,0,1},
			{1,1,1,1,1},
			{1,0,0,0,1},
			{1,0,0,0,1},
		},
		{
			{0,0,1,0,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,0,1,0},
		},
		{
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
		},
		{
			{0,0,1,0,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,0,1,0},
		},
		{
			{0,1,1,1,0},
			{1,0,0,0,1},
			{1,1,1,1,1},
			{1,0,0,0,1},
			{1,0,0,0,1},
		},
	},
	{ //B
		{
			{1,1,1,1,0},
			{1,0,0,0,1},
			{1,1,1,1,0},
			{1,0,0,0,1},
			{1,1,1,1,0},
		},
		{
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
		},
		{
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
		},
		{
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
		},
		{
			{0,1,1,1,1},
			{1,0,0,0,1},
			{0,1,1,1,1},
			{1,0,0,0,1},
			{0,1,1,1,1},
		},
	},
	{ //C
		{
			{0,1,1,1,1},
			{1,0,0,0,0},
			{1,0,0,0,0},
			{1,0,0,0,0},
			{0,1,1,1,1},
		},
		{
			{0,1,1,1,0},
			{0,1,0,0,0},
			{0,1,0,0,0},
			{0,1,0,0,0},
			{0,1,1,1,0},
		},
		{
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
		},
		{
			{0,1,1,1,0},
			{0,0,0,1,0},
			{0,0,0,1,0},
			{0,0,0,1,0},
			{0,1,1,1,0},
		},
		{
			{1,1,1,1,0},
			{0,0,0,0,1},
			{0,0,0,0,1},
			{0,0,0,0,1},
			{1,1,1,1,0},
		},
	},
	{ //D
		{
			{1,1,1,1,0},
			{0,1,0,0,1},
			{0,1,0,0,1},
			{0,1,0,0,1},
			{1,1,1,1,0},
		},
		{
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,0,1,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
		},
		{
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
		},
		{
			{0,1,1,1,0},
			{0,1,0,1,0},
			{0,1,0,1,0},
			{0,1,0,1,0},
			{0,1,1,1,0},
		},
		{
			{0,1,1,1,1},
			{1,0,0,1,0},
			{1,0,0,1,0},
			{1,0,0,1,0},
			{0,1,1,1,1},
		},
	},
	{ //E
		{
			{1,1,1,1,1},
			{1,0,0,0,0},
			{1,1,1,1,0},
			{1,0,0,0,0},
			{1,1,1,1,1},
		},
		{
			{0,1,1,1,0},
			{0,1,0,0,0},
			{0,1,1,1,0},
			{0,1,0,0,0},
			{0,1,1,1,0},
		},
		{
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
			{0,0,1,0,0},
		},
		{
			{0,1,1,1,0},
			{0,0,0,1,0},
			{0,1,1,1,0},
			{0,0,0,1,0},
			{0,1,1,1,0},
		},
		{
			{1,1,1,1,1},
			{0,0,0,0,1},
			{0,1,1,1,1},
			{0,0,0,0,1},
			{1,1,1,1,1},
		},
	},
};
BOOL mDigits[10][5][3] = 
{
	{
		{1,1,1},
		{1,0,1},
		{1,0,1},
		{1,0,1},
		{1,1,1},
	},
	{
		{0,1,0},
		{1,1,0},
		{0,1,0},
		{0,1,0},
		{1,1,1},
	},
	{
		{1,1,1},
		{0,0,1},
		{1,1,1},
		{1,0,0},
		{1,1,1},
	},
	{
		{1,1,1},
		{0,0,1},
		{1,1,1},
		{0,0,1},
		{1,1,1},
	},
	{
		{1,0,1},
		{1,0,1},
		{1,1,1},
		{0,0,1},
		{0,0,1},
	},
	{
		{1,1,1},
		{1,0,0},
		{1,1,1},
		{0,0,1},
		{1,1,1},
	},
	{
		{1,1,1},
		{1,0,0},
		{1,1,1},
		{1,0,1},
		{1,1,1},
	},
	{
		{1,1,1},
		{0,0,1},
		{0,0,1},
		{0,0,1},
		{0,0,1},
	},
	{
		{1,1,1},
		{1,0,1},
		{1,1,1},
		{1,0,1},
		{1,1,1},
	},
	{
		{1,1,1},
		{1,0,1},
		{1,1,1},
		{0,0,1},
		{1,1,1},
	},
};
BOOL mMinis[5][4][8][10] = 
{
	{ //Bricks
		{
			{0,0,0,0,0,0,1,0,0,0},
			{0,0,0,0,0,0,1,1,0,0},
			{0,0,0,0,0,0,1,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,1},
			{1,1,1,0,1,1,0,0,1,1},
			{1,1,1,0,1,1,0,1,1,1},
		},
		{
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,1,0,0,1},
			{1,1,1,0,1,1,1,1,1,1},
			{1,1,1,0,1,1,1,1,1,1},
		},
		{
			{0,0,0,1,1,0,0,0,0,0},
			{0,0,0,1,0,0,0,0,0,0},
			{0,0,0,1,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,1,0,0,1},
			{1,1,1,0,1,1,1,1,1,1},
			{1,1,1,0,1,1,1,1,1,1},
		},
		{
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,1,1,0,1,0,0,1},
		},
	},
	{ //Snakes
		{
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,1,0,0,1,1,1,0},
		},
		{
			{0,0,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,1,1,1,1,0,0,0},
		},
		{
			{0,0,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,1,1,1,1,0,0,0,0,0},
		},
		{
			{0,0,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0},
			{0,1,1,0,0,0,0,0,0,0},
		},
	},
	{ //Racing
		{
			{1,0,0,1,0,0,0,0,0,1},
			{1,0,1,1,1,0,0,0,0,1},
			{1,0,0,1,0,0,0,0,0,1},
			{0,0,1,0,1,0,0,0,0,0},
			{1,0,0,0,0,0,1,0,0,1},
			{1,0,0,0,0,1,1,1,0,1},
			{1,0,0,0,0,0,1,0,0,1},
			{0,0,0,0,0,1,0,1,0,0},
		},
		{
			{0,0,0,0,0,0,0,0,0,0},
			{1,0,0,0,0,0,0,0,0,1},
			{1,0,0,1,0,0,1,0,0,1},
			{1,0,1,1,1,1,1,1,0,1},
			{0,0,0,1,0,0,1,0,0,0},
			{1,0,1,0,1,1,0,1,0,1},
			{1,0,0,0,0,0,0,0,0,1},
			{1,0,0,0,0,0,0,0,0,1},
		},
		{
			{1,0,0,0,0,0,1,0,0,1},
			{0,0,0,0,0,1,1,1,0,0},
			{1,0,0,0,0,0,1,0,0,1},
			{1,0,0,0,0,1,0,1,0,1},
			{1,0,0,1,0,0,0,0,0,1},
			{0,0,1,1,1,0,0,0,0,0},
			{1,0,0,1,0,0,0,0,0,1},
			{1,0,1,0,1,0,0,0,0,1},
		},
		{
			{1,0,0,0,0,0,1,0,0,1},
			{1,0,0,0,0,1,0,1,0,1},
			{0,0,0,0,0,0,0,0,0,0},
			{1,0,0,0,0,0,0,0,0,1},
			{1,0,0,0,0,0,0,0,0,1},
			{1,0,0,0,0,0,0,0,0,1},
			{0,0,0,1,0,0,0,0,0,0},
			{1,0,1,1,1,0,0,0,0,1},
		},
	},
	{ //Shooter
		{
			{1,1,1,1,1,1,1,1,1,1},
			{0,1,1,0,0,1,1,1,1,0},
			{0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,1,1,1,0,0,0},
		},
		{
			{1,1,1,1,1,1,1,1,1,1},
			{0,1,1,0,0,1,1,1,1,0},
			{0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,1,1,1,0,0,0},
		},
		{
			{1,1,1,1,1,1,1,1,1,1},
			{0,1,1,0,0,1,1,1,1,0},
			{0,0,0,0,0,1,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,1,1,1,0,0,0},
		},
		{
			{1,1,1,1,1,1,1,1,1,1},
			{0,1,1,0,0,0,1,1,1,0},
			{0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,1,1,1,0,0,0},
		},
	},
	{ //Tanks
		{
			{0,0,0,0,1,0,1,0,0,0},
			{0,0,0,0,1,1,1,0,0,0},
			{0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,1,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,1,0,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
		},
		{
			{0,0,0,0,1,0,1,0,0,0},
			{0,0,0,0,1,1,1,0,0,0},
			{0,0,0,0,1,1,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,1,0,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
		},
		{
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,1,0,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
		},
		{
			{0,0,0,0,0,0,0,0,1,1},
			{0,0,0,0,0,0,0,1,1,0},
			{0,0,0,0,0,0,0,0,1,1},
			{0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,1,0,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
			{0,0,0,1,1,1,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0},
		},
	},
	
};
BOOL tPieces[7][4][4][4] = 
{
	{ //Reversed L-piece
		{
			{0,0,0,0},
			{0,1,0,0},
			{0,1,0,0},
			{1,1,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,0,0,0},
			{1,1,1,0},
		},
		{ 
			{0,0,0,0},
			{1,1,0,0},
			{1,0,0,0},
			{1,0,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,1,1,0},
			{0,0,1,0},
		},
	},
	{ //L-piece
		{
			{0,0,0,0},
			{1,0,0,0},
			{1,0,0,0},
			{1,1,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,1,1,0},
			{1,0,0,0},
		},
		{ 
			{0,0,0,0},
			{1,1,0,0},
			{0,1,0,0},
			{0,1,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{0,0,1,0},
			{1,1,1,0},
		},
	},
	{ //Square
		{
			{0,0,0,0},
			{0,0,0,0},
			{0,1,1,0},
			{0,1,1,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{0,1,1,0},
			{0,1,1,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{0,1,1,0},
			{0,1,1,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{0,1,1,0},
			{0,1,1,0},
		},
	},
	{ //I piece
		{
			{0,0,1,0},
			{0,0,1,0},
			{0,0,1,0},
			{0,0,1,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,1,1,1},
			{0,0,0,0},
		},
		{
			{0,0,1,0},
			{0,0,1,0},
			{0,0,1,0},
			{0,0,1,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,1,1,1},
			{0,0,0,0},
		},
	},
	{ //Pyramid
		{
			{0,0,0,0},
			{0,0,0,0},
			{0,1,0,0},
			{1,1,1,0},
		},
		{ 
			{0,0,0,0},
			{1,0,0,0},
			{1,1,0,0},
			{1,0,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,1,1,0},
			{0,1,0,0},
		},
		{ 
			{0,0,0,0},
			{0,1,0,0},
			{1,1,0,0},
			{0,1,0,0},
		},
	},
	{ //S-piece
		{
			{0,0,0,0},
			{1,0,0,0},
			{1,1,0,0},
			{0,1,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{0,1,1,0},
			{1,1,0,0},
		},
		{ 
			{0,0,0,0},
			{1,0,0,0},
			{1,1,0,0},
			{0,1,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{0,1,1,0},
			{1,1,0,0},
		},
	},
	{ //Reversed S-piece
		{
			{0,0,0,0},
			{0,1,0,0},
			{1,1,0,0},
			{1,0,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,1,0,0},
			{0,1,1,0},
		},
		{ 
			{0,0,0,0},
			{0,1,0,0},
			{1,1,0,0},
			{1,0,0,0},
		},
		{ 
			{0,0,0,0},
			{0,0,0,0},
			{1,1,0,0},
			{0,1,1,0},
		},
	},
};
BOOL Death[4][5][5] = 
{
	{
		{0,0,0,0,0},
		{0,0,0,0,0},
		{0,0,1,0,0},
		{0,0,0,0,0},
		{0,0,0,0,0},
	},
	{
		{0,0,0,0,0},
		{0,1,1,1,0},
		{0,1,0,1,0},
		{0,1,1,1,0},
		{0,0,0,0,0},
	},
	{
		{1,0,1,0,1},
		{0,0,0,0,0},
		{1,0,0,0,1},
		{0,0,0,0,0},
		{1,0,1,0,1},
	},
	{
		{0,1,0,1,0},
		{1,0,0,0,1},
		{0,0,0,0,0},
		{1,0,0,0,1},
		{0,1,0,1,0},
	},
};
BOOL Car[4][3] = {
	{0,1,0},
	{1,1,1},
	{0,1,0},
	{1,0,1}
};
BOOL Tanks[2][4][3][3] =
{
	{ //Player
		{ //x--
			{0,1,1},
			{1,1,1},
			{0,1,1}
		},
		{ //x++
			{1,1,0},
			{1,1,1},
			{1,1,0}
		},
		{ //y--
			{0,1,0},
			{1,1,1},
			{1,1,1}
		},
		{ //y++
			{1,1,1},
			{1,1,1},
			{0,1,0}
		},
	},
	{ //Enemy
		{ //x--
			{0,1,1},
			{1,1,0},
			{0,1,1}
		},
		{ //x++
			{1,1,0},
			{0,1,1},
			{1,1,0}
		},
		{ //y--
			{0,1,0},
			{1,1,1},
			{1,0,1}
		},
		{ //y++
			{1,0,1},
			{1,1,1},
			{0,1,0}
		},
	},
};
BOOL snakeMaps[14][20][10] = {
	{ //Level 2
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 3
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 4
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,1,1,1,1,0,0,0},
		{1,1,1,1,1,1,1,0,0,0},
		{1,1,1,1,1,1,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,1,1,1,1,1,1},
		{0,0,0,1,1,1,1,1,1,1},
		{0,0,0,1,1,1,1,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 5
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,0,0,1,1,0,0},
		{0,0,1,1,0,0,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,1,0,0,0,0},
		{0,0,0,0,1,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 6
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,1,0,0,0,0},
		{0,0,0,1,1,1,1,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,1,1,1,1,0,0,0},
		{0,0,0,0,1,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 7
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,0,0,1,1,0,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,1,1,1,1,0,0,0},
		{0,0,0,1,1,1,1,0,0,0},
		{0,0,0,0,1,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 8
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,1,1,1,1,0},
		{0,0,0,1,1,1,1,1,1,0},
		{0,0,0,1,1,0,0,0,1,0},
		{0,0,0,1,0,0,0,0,1,0},
		{0,0,0,1,0,0,0,0,1,0},
		{0,0,0,1,0,0,0,0,1,0},
		{0,0,0,1,0,0,1,1,1,0},
		{0,1,1,1,0,0,1,1,1,0},
		{0,1,1,1,0,0,1,1,0,0},
		{0,1,1,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 9
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,1,0,0,0,0,0,0,1,0},
		{0,1,0,0,0,0,0,0,1,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 10
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 11
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,1,1,1,1,1},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,1,1,1,1,1},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 12
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,1,0,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,0,1,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,1,0,1,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,1,0,1,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,1,0,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,1,0,0,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 13
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,1,0},
		{0,0,0,0,0,0,1,0,1,0},
		{0,0,0,0,1,0,1,0,1,0},
		{0,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,0,0},
		{1,0,1,0,1,0,0,0,0,0},
		{1,0,1,0,0,0,0,0,0,0},
		{1,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 14
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,1,0},
		{0,0,0,0,1,1,1,1,1,0},
		{0,0,0,0,1,1,1,1,1,0},
		{0,0,0,0,1,1,1,1,1,0},
		{0,0,0,0,1,1,1,1,1,0},
		{0,0,0,0,0,0,1,0,0,0},
		{0,0,0,0,0,0,1,0,0,0},
		{0,0,0,0,0,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,1,0,0,0,0,0},
		{0,0,0,1,0,0,0,0,0,0},
		{0,0,0,1,0,0,0,0,0,0},
		{0,1,1,1,1,1,0,0,0,0},
		{0,1,1,1,1,1,0,0,0,0},
		{0,1,1,1,1,1,0,0,0,0},
		{0,1,1,1,1,1,0,0,0,0},
		{0,1,0,0,0,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 15
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,1,0,0,0,1,0,0,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,0,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,0,0,0,1,0,0,0,1,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,0,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,1,0,0,0,1,0,0,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,0,0,0,1,0,0,0,1,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
};
BOOL tanksMaps[14][20][10] = {
	{ //Level 2
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{1,0,1,0,0,0,0,1,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,0,1,0,0,0,0,1,0,1},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{1,0,1,0,0,0,0,1,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,0,1,0,0,0,0,1,0,1},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,1,0,0,0}
	},
	{ //Level 3
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{1,1,1,0,0,0,0,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 4
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,1,1,1,1,0,0,0},
		{1,1,1,1,1,1,1,0,0,0},
		{1,1,1,1,1,1,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,1,1,1,1,1,1},
		{0,0,0,1,1,1,1,1,1,1},
		{0,0,0,1,1,1,1,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 5
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,1,1,0,0,0,0},
		{0,0,0,1,1,1,0,0,0,0},
		{0,0,0,1,1,1,0,0,0,0},
		{1,1,1,0,0,0,1,1,1,0},
		{1,1,1,0,0,0,1,1,1,0},
		{1,1,1,0,0,0,1,1,1,0},
		{0,0,0,1,1,1,0,0,0,0},
		{0,0,0,1,1,1,0,0,0,0},
		{0,0,0,1,1,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 6
		{1,1,0,0,0,0,0,0,1,1},
		{1,0,0,0,0,0,0,0,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,1,0,0,0,0},
		{0,0,0,1,1,1,1,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,1,1,1,1,0,0,0},
		{0,0,0,0,1,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 7
		{0,0,0,0,0,0,1,1,1,1},
		{0,0,0,0,0,0,1,1,1,1},
		{0,0,0,0,0,0,1,1,1,1},
		{0,0,0,0,0,0,1,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,1,0,0,0,0,0,0},
		{1,1,1,1,0,0,0,0,0,0},
		{1,1,1,1,0,0,0,0,0,0},
		{1,1,1,1,0,0,0,0,0,0}
	},
	{ //Level 8
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,0,1,0,0,0,0,1,0,1},
		{0,1,1,1,0,0,1,1,1,0},
		{1,0,1,0,0,0,0,1,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,1,0,0,0,0},
		{0,0,0,0,1,1,1,0,0,0},
		{0,0,0,0,0,1,0,0,0,0},
		{0,0,0,0,1,0,1,0,0,0}
	},
	{ //Level 9
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,1,0,0,0,0,0,0,1,0},
		{0,1,0,0,0,0,0,0,1,0},
		{0,0,1,0,0,0,0,1,0,0},
		{0,0,0,1,1,1,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 10
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{1,0,0,1,0,0,1,0,0,0},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,1},
		{1,0,0,0,0,0,0,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{1,0,0,1,0,0,1,0,0,1},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0},
		{0,0,0,1,0,0,1,0,0,0}
	},
	{ //Level 11
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,1,1,1,1},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,1,1,1,1},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,0,0,0,0},
		{0,0,1,1,1,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 12
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,1,0,1,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,0,0,0,1,1,1,1},
		{1,1,1,1,0,1,1,1,1,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 13
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,1,0},
		{0,0,0,0,0,0,1,0,1,0},
		{0,0,0,0,1,0,1,0,1,0},
		{0,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,1,0},
		{1,0,1,0,1,0,1,0,0,0},
		{1,0,1,0,1,0,0,0,0,0},
		{1,0,1,0,1,0,0,0,0,0},
		{1,0,1,0,0,0,0,0,0,0},
		{1,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 14
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,1,0},
		{0,0,0,0,1,1,1,1,1,0},
		{0,0,0,0,1,1,1,1,1,0},
		{0,0,0,0,1,1,1,1,1,0},
		{0,0,0,0,1,0,1,0,1,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,1,0,1,0,1,0,0,0,0},
		{0,1,1,1,1,1,0,0,0,0},
		{0,1,1,1,1,1,0,0,0,0},
		{0,1,1,1,1,1,0,0,0,0},
		{0,1,0,0,0,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
	{ //Level 15
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,1,0,0,0,1,0,0,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,0,0,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{1,0,0,0,1,0,0,0,1,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,1,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,1,0,0,0,0,0,0,0,1},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,1,0,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0}
	},
};
int tSpeedTable[15] = {35, 31, 27, 23, 19, 16, 13, 11, 10, 8, 6, 5, 4, 3, 2}; //Таблица скоростей в тетрисе
int sSpeedTable[15] = {35, 31, 27, 23, 19, 16, 13, 11, 10, 9, 8, 7, 6, 5, 4}; //Таблица скоростей в змейке
int rSpeedTable[15] = {17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3}; //Таблица скоростей в гонках
int spSpeedTable[15] = {70, 65, 60, 55, 50, 45, 40, 37, 34, 31, 28, 25, 22, 19, 16}; //Таблица скоростей в шутере
int spFireRate[15] = {8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4}; //Частота выстрела пуль
int ClearLines[4]; //Какие линии стирать
int ClearedLines=0; //Сколько линий стирать
int DestroyedInvaders=0; //Уничтожено врагов в шутере
int sCoords[18][2]; //Координаты
int PrevSCoords[2];
int SnakeLength, SnakeMoving, PrevSnakeMoving; //Длина змейки и ее движение
int lives; //Количество жизней
BOOL DeathDetected, LevelComplete; //Смерть и пройденный уровень
int DeathX, DeathY; //Где проходит анимация смерти
int CarPosition[4][2]; //Позиция машины
int Bullets[8][2]; //Пули
int CarsLeft, RacingTrackAnimation=0; //Количество оставшихся машин и анимация трассы
int LastSoundPlayed; //Когда прозвучал последний звуковой эффект
int music=0; //Музыка
int SoundPlay=0;
int SnakeMusic=0;
BOOL Flick=FALSE; //Мерцание
int TanksPosition[4][3]; //Координаты танков и их положение
int TanksBullets[16][3]; //Координаты пуль танков
int EnemyTankMove; //Который вражеский танк на данный момент ходит
int HiScoreRecords[5][4]; //Рекорды
CCSprite *PauseIcon;
CCSprite *ScoreDisplay;
CCSprite *HiScoreDisplay;

+(id) scene
{
	// 'scene' is an autorelease object.
	CCScene *scene = [CCScene node];
	
	// 'layer' is an autorelease object.
	HelloWorld *layer = [HelloWorld node];
	
	// add layer as a child to scene
	[scene addChild: layer];
	
	// return the scene
	return scene;
}

// on "init" you need to initialize your instance
-(id) init
{
	// always call "super" init
	// Apple recommends to re-assign "self" with the "super" return value
	if( (self=[super init] )) {
		[self InitGameScene];
		[self schedule:@selector(nextFrame:)]; //Вызывается каждый кадр
	}
	return self;
}

- (bool) isPad { //Детект айпада
	return ([UIScreen mainScreen].bounds.size.height==1024);
}

- (void) InitGameScene { //Инициализация игровой сцены
	if ([self isPad]) { //Если айпад
		GameBackground = [CCSprite spriteWithFile:@"Background-iPad.png" rect:CGRectMake(0, 0, 768, 1024)];
		GameBackground.position = ccp(384, 512);
		[self addChild:GameBackground];
		[GameBackground.texture setAliasTexParameters]; //Disable antialiasing
		//Карта блоков
		BrickMap = [[NSMutableArray alloc] init];
		for (int i=0; i<200; i++)
		{	CCSprite *Bricks = [CCSprite spriteWithFile:@"Bricks-iPad.png" rect:CGRectMake(0, 0, 32, 32)];
			[Bricks.texture setAliasTexParameters]; //Disable antialiasing
			[BrickMap insertObject: Bricks atIndex: i];
			Bricks.position = ccp((i%10)*32+172, (i/10)*(-32)+976);
			[self addChild:Bricks]; }
		//Карта следующего блока
		NextMap = [[NSMutableArray alloc] init];
		for (int i=0; i<16; i++)
		{	CCSprite *Bricks2 = [CCSprite spriteWithFile:@"Bricks-iPad.png" rect:CGRectMake(0, 0, 32, 32)];
			[Bricks2.texture setAliasTexParameters]; //Disable antialiasing
			[NextMap insertObject: Bricks2 atIndex: i];
			Bricks2.position = ccp((i/4)*32+498, (i%4)*(-32)+860);
			[self addChild:Bricks2]; }
		//Карта индикатора набранных очков
		ScoreMap = [[NSMutableArray alloc] init];
		for (int i=0; i<6; i++)
		{	CCSprite *Digits = [CCSprite spriteWithFile:@"DigitalFont-iPad.png" rect:CGRectMake(0, 0, 22, 40)];
			[Digits.texture setAliasTexParameters]; //Disable antialiasing
			[ScoreMap insertObject: Digits atIndex: i];
			Digits.position = ccp(493+i*22, 960);
			[self addChild:Digits]; }
		//Карта индикатора скорости
		SpeedMap = [[NSMutableArray alloc] init];
		for (int i=0; i<2; i++)
		{	CCSprite *Digits2 = [CCSprite spriteWithFile:@"DigitalFont-iPad.png" rect:CGRectMake(0, 0, 22, 40)];
			[Digits2.texture setAliasTexParameters]; //Disable antialiasing
			[SpeedMap insertObject: Digits2 atIndex: i];
			Digits2.position = ccp(577+i*22, 668);
			[self addChild:Digits2]; }
		//Карта индикатора уровня
		LevelMap = [[NSMutableArray alloc] init];
		for (int i=0; i<2; i++)
		{	CCSprite *Digits3 = [CCSprite spriteWithFile:@"DigitalFont-iPad.png" rect:CGRectMake(0, 0, 22, 40)];
			[Digits3.texture setAliasTexParameters]; //Disable antialiasing
			[LevelMap insertObject: Digits3 atIndex: i];
			Digits3.position = ccp(577+i*22, 618);
			[self addChild:Digits3]; }
		//Значок паузы
		PauseIcon = [CCSprite spriteWithFile:@"PauseIcon-iPad.png" rect:CGRectMake(0, 0, 128, 112)];
		PauseIcon.position = ccp(546, 420);
		[self addChild:PauseIcon];
		[PauseIcon.texture setAliasTexParameters]; //Disable antialiasing
		PauseIcon.visible = FALSE;
		//Score
		ScoreDisplay = [CCSprite spriteWithFile:@"Score-iPad.png" rect:CGRectMake(0, 0, 68, 18)];
		ScoreDisplay.position = ccp(558, 921);
		[self addChild:ScoreDisplay];
		[ScoreDisplay.texture setAliasTexParameters]; //Disable antialiasing
		ScoreDisplay.visible = TRUE;
		//HiScore
		HiScoreDisplay = [CCSprite spriteWithFile:@"HiScore-iPad.png" rect:CGRectMake(0, 0, 40, 18)];
		HiScoreDisplay.position = ccp(502, 921);
		[self addChild:HiScoreDisplay];
		[HiScoreDisplay.texture setAliasTexParameters]; //Disable antialiasing
		HiScoreDisplay.visible = FALSE;
	
		//Reset
		But1 = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		But1.position = ccp(488,40);;
		But1.defaultSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But1.activatedSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But1.pressSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But1.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 50, 50)];
		Button1 = [But1.button retain];
		Button1.isToggleable = YES;
		[self addChild:But1];
	
		//Start
		But2 = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		But2.position = ccp(568,40);
		But2.defaultSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But2.activatedSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But2.pressSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But2.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 50, 50)];
		Button2 = [But2.button retain];
		Button2.isToggleable = YES;
		[self addChild:But2];
	
		//Left
		ButLeft = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButLeft.position = ccp(55,115);
		ButLeft.defaultSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButLeft.activatedSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButLeft.pressSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButLeft.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 100, 200)];
		ButtonLeft = [ButLeft.button retain];
		ButtonLeft.isToggleable = YES;
		[self addChild:ButLeft];
	
		//Right
		ButRight = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButRight.position = ccp(265,115);
		ButRight.defaultSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButRight.activatedSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButRight.pressSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButRight.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 10, 200)];
		ButtonRight = [ButRight.button retain];
		ButtonRight.isToggleable = YES;
		[self addChild:ButRight];
	
		//Up
		ButUp = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButUp.position = ccp(160,170);
		ButUp.defaultSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButUp.activatedSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButUp.pressSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButUp.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 100, 100)];
		ButtonUp = [ButUp.button retain];
		ButtonUp.isToggleable = YES;
		[self addChild:ButUp];
	
		//Down
		ButDown = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButDown.position = ccp(160,60);
		ButDown.defaultSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButDown.activatedSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButDown.pressSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButDown.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 100, 100)];
		ButtonDown = [ButDown.button retain];
		ButtonDown.isToggleable = YES;
		[self addChild:ButDown];
	
		//Rotate
		ButRotate = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButRotate.position = ccp(678,115);
		ButRotate.defaultSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButRotate.activatedSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButRotate.pressSprite = [CCSprite spriteWithFile:@"BigButton-iPad.png" rect:CGRectMake(0, 0, 100, 100)];
		ButRotate.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 100, 100)];
		ButtonRotate = [ButRotate.button retain];
		ButtonRotate.isToggleable = YES;
		[self addChild:ButRotate];
	} else { //Если айфон
		GameBackground = [CCSprite spriteWithFile:@"Background.png" rect:CGRectMake(0, 0, 320, 480)];
		GameBackground.position = ccp(160, 240);
		[self addChild:GameBackground];
		[GameBackground.texture setAliasTexParameters]; //Disable antialiasing
		//Карта блоков
		BrickMap = [[NSMutableArray alloc] init];
		for (int i=0; i<200; i++)
		{	CCSprite *Bricks = [CCSprite spriteWithFile:@"Bricks.png" rect:CGRectMake(0, 0, 16, 16)];
			[Bricks.texture setAliasTexParameters]; //Disable antialiasing
			[BrickMap insertObject: Bricks atIndex: i];
			Bricks.position = ccp((i%10)*16+54, (i/10)*(-16)+472);
			[self addChild:Bricks]; }
		//Карта следующего блока
		NextMap = [[NSMutableArray alloc] init];
		for (int i=0; i<16; i++)
		{	CCSprite *Bricks2 = [CCSprite spriteWithFile:@"Bricks.png" rect:CGRectMake(0, 0, 16, 16)];
			[Bricks2.texture setAliasTexParameters]; //Disable antialiasing
			[NextMap insertObject: Bricks2 atIndex: i];
			Bricks2.position = ccp((i/4)*16+217, (i%4)*(-16)+415);
			[self addChild:Bricks2]; }
		//Карта индикатора набранных очков
		ScoreMap = [[NSMutableArray alloc] init];
		for (int i=0; i<6; i++)
		{	CCSprite *Digits = [CCSprite spriteWithFile:@"DigitalFont.png" rect:CGRectMake(0, 0, 11, 20)];
			[Digits.texture setAliasTexParameters]; //Disable antialiasing
			[ScoreMap insertObject: Digits atIndex: i];
			Digits.position = ccp(214.5+i*11, 465);
			[self addChild:Digits]; }
		//Score
		ScoreDisplay = [CCSprite spriteWithFile:@"Score.png" rect:CGRectMake(0, 0, 34, 9)];
		ScoreDisplay.position = ccp(248, 445);
		[self addChild:ScoreDisplay];
		[ScoreDisplay.texture setAliasTexParameters]; //Disable antialiasing
		ScoreDisplay.visible = TRUE;
		//HiScore
		HiScoreDisplay = [CCSprite spriteWithFile:@"HiScore.png" rect:CGRectMake(0, 0, 20, 9)];
		HiScoreDisplay.position = ccp(220, 445);
		[self addChild:HiScoreDisplay];
		[HiScoreDisplay.texture setAliasTexParameters]; //Disable antialiasing
		HiScoreDisplay.visible = FALSE;
		//Карта индикатора скорости
		SpeedMap = [[NSMutableArray alloc] init];
		for (int i=0; i<2; i++)
		{	CCSprite *Digits2 = [CCSprite spriteWithFile:@"DigitalFont.png" rect:CGRectMake(0, 0, 11, 20)];
			[Digits2.texture setAliasTexParameters]; //Disable antialiasing
			[SpeedMap insertObject: Digits2 atIndex: i];
			Digits2.position = ccp(256.5+i*11, 319);
			[self addChild:Digits2]; }		
		//Карта индикатора уровня
		LevelMap = [[NSMutableArray alloc] init];
		for (int i=0; i<2; i++)
		{	CCSprite *Digits3 = [CCSprite spriteWithFile:@"DigitalFont.png" rect:CGRectMake(0, 0, 11, 20)];
			[Digits3.texture setAliasTexParameters]; //Disable antialiasing
			[LevelMap insertObject: Digits3 atIndex: i];
			Digits3.position = ccp(256.5+i*11, 294);
			[self addChild:Digits3]; }
		//Значок паузы
		PauseIcon = [CCSprite spriteWithFile:@"PauseIcon.png" rect:CGRectMake(0, 0, 64, 56)];
		PauseIcon.position = ccp(241, 195);
		[self addChild:PauseIcon];
		[PauseIcon.texture setAliasTexParameters]; //Disable antialiasing
		PauseIcon.visible = FALSE;
		
		//Reset
		But1 = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		But1.position = ccp(225,40);
		But1.defaultSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But1.activatedSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But1.pressSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But1.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 50, 50)];
		Button1 = [But1.button retain];
		Button1.isToggleable = YES;
		[self addChild:But1];
		
		//Start
		But2 = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		But2.position = ccp(285,40);
		But2.defaultSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But2.activatedSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But2.pressSprite = [CCSprite spriteWithFile:@"Button.png" rect:CGRectMake(0, 0, 50, 50)];
		But2.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 50, 50)];
		Button2 = [But2.button retain];
		Button2.isToggleable = YES;
		[self addChild:But2];
		
		//Left
		ButLeft = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButLeft.position = ccp(32,80);
		ButLeft.defaultSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButLeft.activatedSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButLeft.pressSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButLeft.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 60, 160)];
		ButtonLeft = [ButLeft.button retain];
		ButtonLeft.isToggleable = YES;
		[self addChild:ButLeft];
		
		//Right
		ButRight = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButRight.position = ccp(156,80);
		ButRight.defaultSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButRight.activatedSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButRight.pressSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButRight.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 60, 160)];
		ButtonRight = [ButRight.button retain];
		ButtonRight.isToggleable = YES;
		[self addChild:ButRight];
		
		//Up
		ButUp = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButUp.position = ccp(94,120);
		ButUp.defaultSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButUp.activatedSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButUp.pressSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButUp.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 60, 70)];
		ButtonUp = [ButUp.button retain];
		ButtonUp.isToggleable = YES;
		[self addChild:ButUp];
		
		//Down
		ButDown = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButDown.position = ccp(94,40);
		ButDown.defaultSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButDown.activatedSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButDown.pressSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButDown.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 60, 70)];
		ButtonDown = [ButDown.button retain];
		ButtonDown.isToggleable = YES;
		[self addChild:ButDown];
		
		//Rotate
		ButRotate = [[[SneakyButtonSkinnedBase alloc] init] autorelease];
		ButRotate.position = ccp(255,110);
		ButRotate.defaultSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButRotate.activatedSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButRotate.pressSprite = [CCSprite spriteWithFile:@"BigButton.png" rect:CGRectMake(0, 0, 60, 70)];
		ButRotate.button = [[SneakyButton alloc] initWithRect:CGRectMake(0, 0, 60, 70)];
		ButtonRotate = [ButRotate.button retain];
		ButtonRotate.isToggleable = YES;
		[self addChild:ButRotate];	
	}
	
	//Чтение рекорда
	NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	NSString *docsDir = [dirPaths objectAtIndex:0];
	NSString *file = [docsDir stringByAppendingPathComponent: @"hiscores.dat"];
	
	NSFileManager *filemgr = [NSFileManager defaultManager];
	if ([filemgr fileExistsAtPath:file]) {
		NSData *myData = [NSData dataWithContentsOfFile:file];
		NSData *decryptedData = [myData AESDecryptWithPassphrase:@"afuvsbzkrnfahmjg"];
		NSString* decryptedStr = [[NSString alloc] initWithData:decryptedData encoding:NSASCIIStringEncoding];
		NSArray *lines = [decryptedStr componentsSeparatedByString:@"\n"]; //Образуем массив строк
		int Counter=0;
		for (int i=0; i<5; i++) {
			for (int j=0; j<4; j++) {
				HiScoreRecords[i][j] = [[lines objectAtIndex:Counter] intValue];
				Counter++;
			}
		}
	} else {
		//Задаем пустые рекорды
		for (int i=0; i<5; i++) {
			for (int j=0; j<4; j++) {
				HiScoreRecords[i][j]=0;
			}
		}
	}
	
	file = [docsDir stringByAppendingPathComponent: @"lastgame.dat"];
	filemgr = [NSFileManager defaultManager];
	if ([filemgr fileExistsAtPath:file]) {
		NSData *myData = [NSData dataWithContentsOfFile:file];
		NSData *decryptedData = [myData AESDecryptWithPassphrase:@"bricklastdata"];
		NSString* decryptedStr = [[NSString alloc] initWithData:decryptedData encoding:NSASCIIStringEncoding];
		NSArray *lines = [decryptedStr componentsSeparatedByString:@"\n"]; //Образуем массив строк
		selected = [[lines objectAtIndex:0] intValue];
	} else { selected = 0; }
	
	//Sound Effects
	[[SimpleAudioEngine sharedEngine] preloadBackgroundMusic:@"mr_9999_00.wav"];
	[[SimpleAudioEngine sharedEngine] preloadBackgroundMusic:@"mr_9999_bricks.wav"];
	[[SimpleAudioEngine sharedEngine] preloadEffect:@"mr_9999_explode.wav"];
	[[SimpleAudioEngine sharedEngine] preloadEffect:@"mr_9999_startgame.wav"];
	[[SimpleAudioEngine sharedEngine] preloadEffect:@"mr_9999_01.wav"];
	[[SimpleAudioEngine sharedEngine] preloadEffect:@"mr_9999_05.wav"];
	[[SimpleAudioEngine sharedEngine] preloadEffect:@"mr_9999_06.wav"];
	[[SimpleAudioEngine sharedEngine] preloadEffect:@"mr_9999_14.wav"];
	[[SimpleAudioEngine sharedEngine] preloadEffect:@"mr_9999_15.wav"];
	if (selected<42 || selected>46) [[SimpleAudioEngine sharedEngine] playBackgroundMusic:@"mr_9999_00.wav" loop:FALSE];
	SoundFX=0;
	
	if (selected==42) { [self LoadBricksGame]; }
	else if (selected==43) { [self LoadSnakeGame]; }
	else if (selected==44) { [self LoadRacingGame]; }
	else if (selected==45) { [self LoadShooterGame]; }
	else if (selected==46) { [self LoadTanksGame]; }
	else {selected = 0; speed = 1, level = 1, mode = 1, game = 1; [self InitTitleMap]; }
	
	//Обновление текущей скорости
	[self RefreshSpeed];
	//Обновление текущего уровня
	[self RefreshLevel];
}

- (void) InitTitleMap { //Тру тайтл скрин
	//Заполняем карту тайлами
	for (int i=0; i<10; i++) { //Горизонталь
		for (int j=0; j<20; j++) { //Вертикаль
			if (tScreens[j][i]) {
				brmap[i][j]=TRUE;
				((CCSprite *)[BrickMap objectAtIndex:i+j*10]).visible = TRUE;
			} else {
				brmap[i][j]=FALSE;
				((CCSprite *)[BrickMap objectAtIndex:i+j*10]).visible = FALSE;
			}
		}
	}
	//Стираем NEXT
	x=0; y=0;
	while (x<4) {
		while (y<4) {
			((CCSprite *)[NextMap objectAtIndex:x*4+y]).visible = FALSE;
			y++;
		}
		y=0; x++;
	}
	x=0;
}

- (void) BrickGameTitle { //Тот самый Title Screen
	if (timer>0) timer--;
	else {
		if (brmap[y][x])
		{ 
			((CCSprite *)[BrickMap objectAtIndex:y+x*10]).visible = FALSE; brmap[y][x]=FALSE;
		}
		else
		{
			((CCSprite *)[BrickMap objectAtIndex:y+x*10]).visible = TRUE; brmap[y][x]=TRUE;
		}
		if (x==4 && y==5) {x=-1; y=0; z=0; timer=60;}
		if (z%4==0 && x>18-z/4) z++;
		if (z%4==1 && y>8-z/4) z++;
		if (z%4==2 && x<1+z/4) z++;
		if (z%4==3 && y<2+z/4) z++;
		if (z%4==0) x++;
		if (z%4==1) y++;
		if (z%4==2) x--;
		if (z%4==3) y--;
	}
}

- (void) ClearMap { //Стираем карту
	x=0; y=0;
	while (x<10) {
		while (y<20) {
			((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = FALSE;
			brmap[x][y]=FALSE;
			y++;
		}
		y=0; x++;
	}
}

- (void) MainMenu { //Главное меню
	for (int i=0; i<10; i++) {
		for (int j=0; j<20; j++) {
			((CCSprite *)[BrickMap objectAtIndex:i+j*10]).visible = FALSE;
		}
	}
	//Стираем NEXT
	x=0; y=0;
	while (x<4) {
		while (y<4) {
			((CCSprite *)[NextMap objectAtIndex:x*4+y]).visible = FALSE;
			y++;
		}
		y=0; x++;
	}
	//Перерисовка рекорда
	[self RefreshHiScore];
	
	LetterAnimation++; //Анимация букв
	if (LetterAnimation>85) LetterAnimation=0;
	for (int i=0; i<5; i++) {
		for (int j=0; j<5; j++) {
			if (LetterAnimation<8 || LetterAnimation>63)
				((CCSprite *)[BrickMap objectAtIndex:i+2+j*10]).visible = mLetters[game-1][0][j][i];
			if ((LetterAnimation>7 && LetterAnimation<16) || (LetterAnimation>55 && LetterAnimation<64))
				((CCSprite *)[BrickMap objectAtIndex:i+2+j*10]).visible = mLetters[game-1][1][j][i];
			if ((LetterAnimation>15 && LetterAnimation<24) || (LetterAnimation>47 && LetterAnimation<56))
				((CCSprite *)[BrickMap objectAtIndex:i+2+j*10]).visible = mLetters[game-1][2][j][i];
			if ((LetterAnimation>23 && LetterAnimation<32) || (LetterAnimation>39 && LetterAnimation<48))
				((CCSprite *)[BrickMap objectAtIndex:i+2+j*10]).visible = mLetters[game-1][3][j][i];
			if (LetterAnimation>31 && LetterAnimation<40)
				((CCSprite *)[BrickMap objectAtIndex:i+2+j*10]).visible = mLetters[game-1][4][j][i];
		}
	}
	
	MiniAnimation++; //Анимация игрового действия
	if (MiniAnimation>120) MiniAnimation=0;
	for (int i=0; i<10; i++) {
		for (int j=0; j<8; j++) {
			if (MiniAnimation<30)
				((CCSprite *)[BrickMap objectAtIndex:i+(j+6)*10]).visible = mMinis[game-1][0][j][i];
			else if (MiniAnimation<60)
				((CCSprite *)[BrickMap objectAtIndex:i+(j+6)*10]).visible = mMinis[game-1][1][j][i];
			else if (MiniAnimation<90)
				((CCSprite *)[BrickMap objectAtIndex:i+(j+6)*10]).visible = mMinis[game-1][2][j][i];
			else
				((CCSprite *)[BrickMap objectAtIndex:i+(j+6)*10]).visible = mMinis[game-1][3][j][i];
		}
	}
	
	//Цифры
	for (int i=0; i<3; i++) {
		for (int j=0; j<5; j++) {
			((CCSprite *)[BrickMap objectAtIndex:i+1+(j+15)*10]).visible = mDigits[mode/10%10][j][i];
			((CCSprite *)[BrickMap objectAtIndex:i+5+(j+15)*10]).visible = mDigits[mode%10][j][i];
		}
	}
	
	//Переключение скорости
	if (ButtonRight.active && RightButtonPushed==1) {
		speed++; if (speed>15) speed=1; [self RefreshSpeed]; SoundPlay=1;
	}
	//Переключение уровня
	if (ButtonLeft.active && LeftButtonPushed==1) {
		level++; if (level>15) level=1; [self RefreshLevel]; SoundPlay=1;
	}
	//Переключение игры
	if (ButtonRotate.active && RotateButtonPushed==1) {
		MiniAnimation=0; LetterAnimation=0; //Сброс анимации
		game++; if (game>5) game=1;
		SoundPlay=1;
	}
	//Переключение режима
	if (ButtonUp.active && UpButtonPushed==1) { mode--; SoundPlay=1; }
	if (ButtonDown.active && DownButtonPushed==1) { mode++; SoundPlay=1; }
	if (mode<1 && game==2) mode=4; else if (mode<1 && game!=2) mode=2;
	if (mode>4 && game==2) mode=1; else if (mode>2 && game!=2) mode=1;
	//Запуск игр
	if (Button2.active && StartButtonPushed==1) {
		[[SimpleAudioEngine sharedEngine] stopBackgroundMusic];
		selected=1+game;
		StartButtonPushed=2;
		if (game==1) { [self InitBricksGame]; [[SimpleAudioEngine sharedEngine] playBackgroundMusic:@"mr_9999_bricks.wav" loop:FALSE];} //Кирпичи
		if (game>1) {score=0; lives=4;} //Задаем количество очков и жизней
		if (game==2) [self InitSnakeGame]; //Змейка
		if (game==3) [self InitRacingGame]; //Гонка
		if (game==4) [self InitShooterGame]; //Шутер
		if (game==5) [self InitTanksGame]; //Танки
	}
}

- (void) InitBricksGame { //Инициализировать игру про кирпичи
	CurrentBrick[0] = arc4random() % 7; //Piece
	CurrentBrick[1] = arc4random() % 4; //Rotate
	NextBrick[0] = arc4random() % 7; //Piece
	NextBrick[1] = arc4random() % 4; //Rotate
	//Стираем карту
	[self ClearMap];
	//Рисуем уровень
	for (int j=0; j<level-1; j++) {
		for (int k=0; k<6; k++) {
			int m=arc4random() % 10;
			BOOL Check=TRUE;
			while (Check) {
				if (brmap[m][(19-j)]) m++;
				else { ((CCSprite *)[BrickMap objectAtIndex:m+(19-j)*10]).visible = TRUE; brmap[m][(19-j)]=TRUE; Check=FALSE; }
				if (m>9) m=0;
			}
		}
	}
	//Отрисовать следующий кусок
	[self DrawNextPiece];
	//Таймер и координаты
	timer=tSpeedTable[speed-1]; XBrick=3; YBrick=-3; YBrickPrev=-4;
	PrevBrick[0] = 0;
	PrevBrick[1] = 0;
	//Количество очков и стертых линий, задержка внизу и когда появляется новая линия, а также когда последняя линия была стерта
	score=0; TotalClearedLines=0; YBrickLastLine=0;	NewBrickLineTimer=1859; LastLineCleared=301;
	LastSoundPlayed=0; music=360;
	[self RefreshScore];
	[self RefreshScreen];
}

- (void) LoadBricksGame { //Загрузить игру про кирпичи
	//Запись рекорда
	NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	NSString *docsDir = [dirPaths objectAtIndex:0];
	NSString *file = [docsDir stringByAppendingPathComponent: @"lastgame.dat"];
	
	NSData *myData = [NSData dataWithContentsOfFile:file];
	NSData *decryptedData = [myData AESDecryptWithPassphrase:@"bricklastdata"];
	NSString* decryptedStr = [[NSString alloc] initWithData:decryptedData encoding:NSASCIIStringEncoding];
	NSArray *lines = [decryptedStr componentsSeparatedByString:@"\n"]; //Образуем массив строк
		
	mode = [[lines objectAtIndex:1] intValue];
	speed = [[lines objectAtIndex:2] intValue];
	level = [[lines objectAtIndex:3] intValue];
	score = [[lines objectAtIndex:4] intValue];
	game = 1;
	
	for (int i=0; i<10; i++) {
		for (int j=0; j<20; j++) {
			brmap[i][j]=[[lines objectAtIndex:5+j+i*20] intValue];
		}
	}
	
	TotalClearedLines = [[lines objectAtIndex:205] intValue];
	CurrentBrick[0] = [[lines objectAtIndex:206] intValue];
	CurrentBrick[1] = [[lines objectAtIndex:207] intValue];
	NextBrick[0] = [[lines objectAtIndex:208] intValue];
	NextBrick[1] = [[lines objectAtIndex:209] intValue];
	XBrick = [[lines objectAtIndex:210] intValue];
	YBrick = [[lines objectAtIndex:211] intValue];
	ClearedLines = [[lines objectAtIndex:212] intValue];
	LastLineCleared = [[lines objectAtIndex:213] intValue];
	timer = [[lines objectAtIndex:214] intValue];
	ClearLines[0] = [[lines objectAtIndex:215] intValue];
	ClearLines[1] = [[lines objectAtIndex:216] intValue];
	ClearLines[2] = [[lines objectAtIndex:217] intValue];
	ClearLines[3] = [[lines objectAtIndex:218] intValue];
	z = [[lines objectAtIndex:219] intValue];
	NewBrickLineTimer = [[lines objectAtIndex:220] intValue];
	
	//Отрисовать следующий кусок
	[self DrawNextPiece];
	//Таймер и координаты
	YBrickPrev=-4;
	PrevBrick[0] = CurrentBrick[0];
	PrevBrick[1] = CurrentBrick[1];
	//Количество очков и стертых линий, задержка внизу и когда появляется новая линия, а также когда последняя линия была стерта
	YBrickLastLine=0;
	LastSoundPlayed=0;
	[self RefreshScore];
	[self RefreshScreen];
	
	//Отрисовка текущего куска
	x=0; y=0;
	while (x<4) {
		while (y<4) {
			if (tPieces[CurrentBrick[0]][CurrentBrick[1]][y][x] && YBrick+y>=0)
			{ ((CCSprite *)[BrickMap objectAtIndex:(x+XBrick)+(y+YBrick)*10]).visible = TRUE; }
			y++;
		}
		y=0; x++;
	}
}

- (void) InitSnakeGame { //Инициализировать игру про змейку
	//Стираем карту или рисуем карту со змейкой
	if (level==1) [self ClearMap]; else [self DrawSnakeMap];
	//Таймер и координаты
	timer=sSpeedTable[speed-1];
	//Количество очков, длина и координаты змейки, змейка не двигается
	SnakeLength=3; SnakeMoving=0;
	sCoords[0][0]=3; sCoords[0][1]=19;
	sCoords[1][0]=4; sCoords[1][1]=19;
	sCoords[2][0]=5; sCoords[2][1]=19;
	DeathDetected=FALSE; LevelComplete=FALSE;
	music=120;
	SnakeMusic=0;
	Flick=FALSE;
	[self RandomizeSnakeDot]; //Сгенерировать случайные координаты мерцающей точки
	[self RefreshScore];
	[self RefreshLives];
	[self RefreshLevel];
	[self RefreshSpeed];
}

- (void) LoadSnakeGame { //Загрузить игру про змейку
	//Запись рекорда
	NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	NSString *docsDir = [dirPaths objectAtIndex:0];
	NSString *file = [docsDir stringByAppendingPathComponent: @"lastgame.dat"];
	
	NSData *myData = [NSData dataWithContentsOfFile:file];
	NSData *decryptedData = [myData AESDecryptWithPassphrase:@"bricklastdata"];
	NSString* decryptedStr = [[NSString alloc] initWithData:decryptedData encoding:NSASCIIStringEncoding];
	NSArray *lines = [decryptedStr componentsSeparatedByString:@"\n"]; //Образуем массив строк
	
	mode = [[lines objectAtIndex:1] intValue];
	speed = [[lines objectAtIndex:2] intValue];
	level = [[lines objectAtIndex:3] intValue];
	score = [[lines objectAtIndex:4] intValue];
	game = 2;
	
	int Counter=4;
	for (int i=0; i<18; i++) {
		for (int j=0; j<2; j++) {
			Counter++;
			sCoords[i][j] = [[lines objectAtIndex:Counter] intValue];
		}
	}
	
	SnakeLength = [[lines objectAtIndex:41] intValue];
	SnakeMoving = [[lines objectAtIndex:42] intValue];
	timer = [[lines objectAtIndex:43] intValue];
	LevelComplete = [[lines objectAtIndex:44] intValue];
	DeathDetected = [[lines objectAtIndex:45] intValue];
	DeathX = [[lines objectAtIndex:46] intValue];
	DeathY = [[lines objectAtIndex:47] intValue];
	lives = [[lines objectAtIndex:48] intValue];
	//Снимаем паузу, если умерли или левел ап
	if (LevelComplete || DeathDetected) selected-=40;
	//Стираем NEXT
	x=0;
	while (x<16) {
		((CCSprite *)[NextMap objectAtIndex:x]).visible = FALSE; x++;
	}
	[self RefreshScore];
	[self RefreshLives];
	[self RefreshLevel];
	[self RefreshSpeed];
	
	//Стираем карту или рисуем карту со змейкой
	if (level==1) [self ClearMap]; else [self DrawSnakeMap];
}

- (void) InitRacingGame { //Инициализировать игру про гонку
	//Стираем карту
	[self ClearMap];
	//Таймер и координаты
	timer=rSpeedTable[speed-1];
	//Количество очков, координаты машины и т.д.
	CarPosition[0][0]=0; CarPosition[0][1]=16;
	if (mode==1) {
		CarPosition[1][0]=arc4random()%2; 
		CarPosition[2][0]=arc4random()%2;
		CarPosition[3][0]=arc4random()%2;
		CarPosition[1][1]=-4;
		CarPosition[2][1]=-13;
		CarPosition[3][1]=-22;
	}
	else if (mode==2) {
		CarPosition[1][0]=arc4random()%6; 
		CarPosition[2][0]=arc4random()%6;
		CarPosition[3][0]=arc4random()%6;
		CarPosition[1][1]=-4;
		CarPosition[2][1]=-14;
		CarPosition[3][1]=-24;
	}
	DeathDetected=FALSE; LevelComplete=FALSE;
	CarsLeft=100; RacingTrackAnimation=0;
	music=120;
	[self RefreshScore];
	[self RefreshLives];
	[self RefreshLevel];
	[self RefreshSpeed];
}

- (void) LoadRacingGame { //Загрузить игру про гонку
	//Запись рекорда
	NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	NSString *docsDir = [dirPaths objectAtIndex:0];
	NSString *file = [docsDir stringByAppendingPathComponent: @"lastgame.dat"];
	
	NSData *myData = [NSData dataWithContentsOfFile:file];
	NSData *decryptedData = [myData AESDecryptWithPassphrase:@"bricklastdata"];
	NSString* decryptedStr = [[NSString alloc] initWithData:decryptedData encoding:NSASCIIStringEncoding];
	NSArray *lines = [decryptedStr componentsSeparatedByString:@"\n"]; //Образуем массив строк
	
	mode = [[lines objectAtIndex:1] intValue];
	speed = [[lines objectAtIndex:2] intValue];
	level = [[lines objectAtIndex:3] intValue];
	score = [[lines objectAtIndex:4] intValue];
	game = 3;
	
	CarPosition[0][0] = [[lines objectAtIndex:5] intValue];
	CarPosition[0][1] = [[lines objectAtIndex:6] intValue];
	CarPosition[1][0] = [[lines objectAtIndex:7] intValue];
	CarPosition[1][1] = [[lines objectAtIndex:8] intValue];
	CarPosition[2][0] = [[lines objectAtIndex:9] intValue];
	CarPosition[2][1] = [[lines objectAtIndex:10] intValue];
	CarPosition[3][0] = [[lines objectAtIndex:11] intValue];
	CarPosition[3][1] = [[lines objectAtIndex:12] intValue];
	CarsLeft = [[lines objectAtIndex:13] intValue];
	RacingTrackAnimation = [[lines objectAtIndex:14] intValue];
	timer = [[lines objectAtIndex:15] intValue];
	LevelComplete = [[lines objectAtIndex:16] intValue];
	lives = [[lines objectAtIndex:17] intValue];
	DeathDetected = [[lines objectAtIndex:18] intValue];
	DeathX = [[lines objectAtIndex:19] intValue];
	DeathY = [[lines objectAtIndex:20] intValue];
	//Снимаем паузу, если умерли или левел ап
	if (LevelComplete || DeathDetected) selected-=40;
	//Стираем NEXT
	x=0;
	while (x<16) {
		((CCSprite *)[NextMap objectAtIndex:x]).visible = FALSE; x++;
	}
	
	[self ClearMap];
	//Анимация движущейся трассы
	for (int i=0; i<20; i++) {
		if ((RacingTrackAnimation+i)%5>1) {
			if (mode==1) ((CCSprite *)[BrickMap objectAtIndex:i*10]).visible = TRUE;
			((CCSprite *)[BrickMap objectAtIndex:9+i*10]).visible = TRUE;
		}
	}
	
	for (int i=0; i<4; i++) { //Рисуем машины
		for (int j=0; j<3; j++) {
			for (int k=0; k<4; k++) {
				if (k+CarPosition[i][1]>-1 && k+CarPosition[i][1]<20) {
					if (mode==1) ((CCSprite *)[BrickMap objectAtIndex:(j+2+CarPosition[i][0]*3)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
					if (mode==2) {
						if (i==0) {
							((CCSprite *)[BrickMap objectAtIndex:(j+CarPosition[i][0]*3)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
						} else {
							//Первая машина
							if (CarPosition[i][0]%2==0) ((CCSprite *)[BrickMap objectAtIndex:j+(k+CarPosition[i][1])*10]).visible = Car[k][j];
							//Вторая машина
							if (CarPosition[i][0]%4==1 || CarPosition[i][0]%4==2) ((CCSprite *)[BrickMap objectAtIndex:(j+3)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
							//Третья машина
							if (CarPosition[i][0]>2) ((CCSprite *)[BrickMap objectAtIndex:(j+6)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
						}
					}
				}
			}
		}
	}
	
	[self RefreshScore];
	[self RefreshLives];
	[self RefreshLevel];
	[self RefreshSpeed];
}

- (void) InitShooterGame { //Инициализировать игру про шутер
	//Стираем карту
	[self ClearMap];
	//Рисуем линии
	for (int i=0; i<level-1; i++) {
		for (int k=0; k<(1+arc4random() % 9); k++) { //От 1-й до 9-ти точек
			int m=arc4random() % 10;
			BOOL Check=TRUE;
			while (Check) {
				if (brmap[m][i]) m++;
				else { ((CCSprite *)[BrickMap objectAtIndex:m+i*10]).visible = TRUE; brmap[m][i]=TRUE; Check=FALSE; }
				if (m>9) m=0;
			}
		}
	}
	//Инициализация пуль
	for (int i=0; i<8; i++) { Bullets[i][0]=0; Bullets[i][1]=-1; }
	DestroyedInvaders=0; //Уничтожено врагов
	XBrick=5; //Координата игрока
	timer=spSpeedTable[speed-1]; //Таймер
	DeathDetected=FALSE; LevelComplete=FALSE;
	music=120;
	[self RefreshScore];
	[self RefreshLives];
}

- (void) LoadShooterGame { //Загрузить игру про шутер
	//Запись рекорда
	NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	NSString *docsDir = [dirPaths objectAtIndex:0];
	NSString *file = [docsDir stringByAppendingPathComponent: @"lastgame.dat"];
	
	NSData *myData = [NSData dataWithContentsOfFile:file];
	NSData *decryptedData = [myData AESDecryptWithPassphrase:@"bricklastdata"];
	NSString* decryptedStr = [[NSString alloc] initWithData:decryptedData encoding:NSASCIIStringEncoding];
	NSArray *lines = [decryptedStr componentsSeparatedByString:@"\n"]; //Образуем массив строк
	
	mode = [[lines objectAtIndex:1] intValue];
	speed = [[lines objectAtIndex:2] intValue];
	level = [[lines objectAtIndex:3] intValue];
	score = [[lines objectAtIndex:4] intValue];
	game = 4;
	
	for (int i=0; i<10; i++) {
		for (int j=0; j<20; j++) {
			brmap[i][j]=[[lines objectAtIndex:5+j+i*20] intValue];
		}
	}
	int Counter = 204;
	for (int i=0; i<8; i++) {
		for (int j=0; j<2; j++) {
			Counter++;
			Bullets[i][j] = [[lines objectAtIndex:Counter] intValue];
		}
	}
	
	XBrick = [[lines objectAtIndex:221] intValue];
	DestroyedInvaders = [[lines objectAtIndex:222] intValue];
	timer = [[lines objectAtIndex:223] intValue];
	LevelComplete = [[lines objectAtIndex:224] intValue];
	lives = [[lines objectAtIndex:225] intValue];
	DeathDetected = [[lines objectAtIndex:226] intValue];
	DeathX = [[lines objectAtIndex:227] intValue];
	DeathY = [[lines objectAtIndex:228] intValue];
	
	//Снимаем паузу, если умерли или левел ап
	if (LevelComplete || DeathDetected) selected-=40;
	//Стираем NEXT
	x=0;
	while (x<16) {
		((CCSprite *)[NextMap objectAtIndex:x]).visible = FALSE; x++;
	}
	//Перерисовка экрана
	[self RefreshScreen];
	//Рисуем главного игрока
	((CCSprite *)[BrickMap objectAtIndex:180+XBrick]).visible = TRUE;
	((CCSprite *)[BrickMap objectAtIndex:190+XBrick]).visible = TRUE;
	if (XBrick>0) ((CCSprite *)[BrickMap objectAtIndex:190+XBrick-1]).visible = TRUE;
	if (XBrick<9) ((CCSprite *)[BrickMap objectAtIndex:190+XBrick+1]).visible = TRUE;
	for (int i=0; i<6; i++) { //Перебираем пули
		if (Bullets[i][1]>-1) {
			((CCSprite *)[BrickMap objectAtIndex:Bullets[i][0]+Bullets[i][1]*10]).visible = TRUE; //Рисуем пули
		}
	}
	[self RefreshScore];
	[self RefreshLives];
	[self RefreshLevel];
	[self RefreshSpeed];
}

- (void) InitTanksGame { //Инициализировать игру про танки
	x=0; y=0;
	while (x<10) {
		while (y<20) {
			if (tanksMaps[level-2][y][x] && level>1) {((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = TRUE; trmap[x][y]=9;}
			else {((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = FALSE; trmap[x][y]=0;}
			y++;
		}
		y=0; x++;
	} //Стираем карту
	timer=tSpeedTable[speed-1]; //Таймер
	DeathDetected=FALSE; LevelComplete=FALSE;
	music=120;
	//Начальные положения врагов
	TanksPosition[0][0]=3; TanksPosition[0][1]= 11; TanksPosition[0][2]=2;
	TanksPosition[1][0]=3; TanksPosition[1][1]=-12; TanksPosition[1][2]=2;
	TanksPosition[2][0]=3; TanksPosition[2][1]=-12; TanksPosition[2][2]=2;
	TanksPosition[3][0]=3; TanksPosition[3][1]=-12; TanksPosition[3][2]=2;
	for (int i=0; i<16; i++) {
		TanksBullets[i][0]=3; TanksBullets[i][1]=-12; TanksBullets[i][2]=4;
	}
	EnemyTankMove=1; //Который вражеский танк на данный момент ходит
	BulletTime=5; //Летят пули
	DestroyedInvaders=0; //Уничтожено врагов
	[self RefreshScore];
	[self RefreshLives];
	[self RefreshLevel];
	[self RefreshSpeed];
}

- (void) LoadTanksGame { //Загрузить игру про танки
	//Запись рекорда
	NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	NSString *docsDir = [dirPaths objectAtIndex:0];
	NSString *file = [docsDir stringByAppendingPathComponent: @"lastgame.dat"];
	
	NSData *myData = [NSData dataWithContentsOfFile:file];
	NSData *decryptedData = [myData AESDecryptWithPassphrase:@"bricklastdata"];
	NSString* decryptedStr = [[NSString alloc] initWithData:decryptedData encoding:NSASCIIStringEncoding];
	NSArray *lines = [decryptedStr componentsSeparatedByString:@"\n"]; //Образуем массив строк
	
	mode = [[lines objectAtIndex:1] intValue];
	speed = [[lines objectAtIndex:2] intValue];
	level = [[lines objectAtIndex:3] intValue];
	score = [[lines objectAtIndex:4] intValue];
	game = 5;
	
	for (int i=0; i<10; i++) {
		for (int j=0; j<20; j++) {
			trmap[i][j]=[[lines objectAtIndex:5+j+i*20] intValue];
		}
	}
	int Counter = 204;
	for (int i=0; i<4; i++) {
		for (int j=0; j<3; j++) {
			Counter++;
			TanksPosition[i][j] = [[lines objectAtIndex:Counter] intValue];
		}
	}
	Counter = 216;
	for (int i=0; i<16; i++) {
		for (int j=0; j<3; j++) {
			Counter++;
			TanksBullets[i][j] = [[lines objectAtIndex:Counter] intValue];
		}
	}
	
	EnemyTankMove = [[lines objectAtIndex:265] intValue];
	BulletTime = [[lines objectAtIndex:266] intValue];
	DestroyedInvaders = [[lines objectAtIndex:267] intValue];
	timer = [[lines objectAtIndex:268] intValue];
	LevelComplete = [[lines objectAtIndex:269] intValue];
	lives = [[lines objectAtIndex:270] intValue];
	DeathDetected = [[lines objectAtIndex:271] intValue];
	DeathX = [[lines objectAtIndex:272] intValue];
	DeathY = [[lines objectAtIndex:273] intValue];
	
	//Снимаем паузу, если умерли или левел ап
	if (LevelComplete || DeathDetected) selected-=40;
	//Стираем NEXT
	x=0;
	while (x<16) {
		((CCSprite *)[NextMap objectAtIndex:x]).visible = FALSE; x++;
	}
	x=0; y=0;
	while (x<10) {
		while (y<20) {
			if (trmap[x][y]==9) {((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = TRUE;}
			else { ((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = FALSE; trmap[x][y]=0; }
			y++;
		}
		y=0; x++;
	} //Стираем карту
	//Рисуем танки
	for (int i=0; i<4; i++) {
		for (int j=0; j<3; j++) {
			for (int k=0; k<3; k++) {
				if (i==0) {
					if (TanksPosition[i][1]>-1 && TanksPosition[i][1]<20 && Tanks[0][TanksPosition[i][2]][k][j]) {
						((CCSprite *)[BrickMap objectAtIndex:(j+TanksPosition[i][0])+(k+TanksPosition[i][1])*10]).visible = TRUE;
					}
				} else {
					if (TanksPosition[i][1]>-1 && TanksPosition[i][1]<20 && Tanks[1][TanksPosition[i][2]][k][j]) {
						((CCSprite *)[BrickMap objectAtIndex:(j+TanksPosition[i][0])+(k+TanksPosition[i][1])*10]).visible = TRUE;
					}
				}
			}
		}
	}
	//Рисуем пули
	for (int i=0; i<16; i++) {
		if (TanksBullets[i][0]>-1 && TanksBullets[i][0]<10 && TanksBullets[i][1]>-1 && TanksBullets[i][1]<20 && TanksBullets[i][2]<4) {
			((CCSprite *)[BrickMap objectAtIndex:(TanksBullets[i][0])+(TanksBullets[i][1])*10]).visible = TRUE;
		}
	}
	[self RefreshScore];
	[self RefreshLives];
	[self RefreshLevel];
	[self RefreshSpeed];
}

- (void) DrawNextPiece { //Отрисовать следующий кусок
	x=0; y=0;
	while (x<4) {
		while (y<4) {
			((CCSprite *)[NextMap objectAtIndex:x*4+y]).visible = tPieces[NextBrick[0]][NextBrick[1]][y][x];
			y++;
		}
		y=0; x++;
	}
}

- (BOOL) BricksCheckCollision { //Проверка коллизий
	BOOL Check = TRUE;
	x=0; y=0;
	while (x<4) {
		while (y<4) {
			if (tPieces[CurrentBrick[0]][CurrentBrick[1]][y][x])
			{
				if (XBrick+x>9 || XBrick+x<0 || YBrick+y>19) { Check=FALSE; } //Столкновение с границами
				else if (YBrick+y<0) { Check=Check; } //Фигура не появилась на экране
				else if (brmap[x+XBrick][y+YBrick]==tPieces[CurrentBrick[0]][CurrentBrick[1]][y][x]) { Check=FALSE; } //Столкновение с кубиками на карте
			}
			y++;
		}
		y=0; x++;
	}
	return Check;
}

- (BOOL) TanksCheckCollision:(int)ChTank { //Проверка коллизий танков
	BOOL Check = TRUE;
	for (int j=0; j<3; j++) {
		for (int k=0; k<3; k++) {
			if (ChTank==0) {
				if (Tanks[0][TanksPosition[ChTank][2]][k][j] && trmap[TanksPosition[ChTank][0]+j][TanksPosition[ChTank][1]+k]>0 && trmap[TanksPosition[ChTank][0]+j][TanksPosition[ChTank][1]+k]!=ChTank+1) Check=FALSE;
			} else {
				if (Tanks[1][TanksPosition[ChTank][2]][k][j] && trmap[TanksPosition[ChTank][0]+j][TanksPosition[ChTank][1]+k]>0 && trmap[TanksPosition[ChTank][0]+j][TanksPosition[ChTank][1]+k]!=ChTank+1) Check=FALSE;
			}
		}
	}
	return Check;
}

- (void) CheckClearLines { //Какие линии будем стирать
	ClearedLines=0; //Количество стертых линий
	for (y=19; y>-1; y--) {
		BOOL CheckLine = TRUE;
		for (x=0; x<10; x++) {
			if (!(brmap[x][y])) CheckLine = FALSE;
		}
		if (CheckLine) { //Эту линию можно стирать
			ClearLines[ClearedLines]=y;
			ClearedLines++;
		}
	}
	if (ClearedLines>0) { timer=19; z=0; }
}

- (void) ClearingLines { //Стираем линии
	timer--;
	if (timer==18) SoundPlay=15;
	//Красиво, как в тетрисе
	if (timer==16) { (brmap[4][ClearLines[z]+z])=FALSE; (brmap[5][ClearLines[z]+z])=FALSE; }
	if (timer==13) { (brmap[3][ClearLines[z]+z])=FALSE; (brmap[6][ClearLines[z]+z])=FALSE; }
	if (timer==10) { (brmap[2][ClearLines[z]+z])=FALSE; (brmap[7][ClearLines[z]+z])=FALSE; }
	if (timer==7)  { (brmap[1][ClearLines[z]+z])=FALSE; (brmap[8][ClearLines[z]+z])=FALSE; }
	if (timer==4)  { (brmap[0][ClearLines[z]+z])=FALSE; (brmap[9][ClearLines[z]+z])=FALSE; }
	if (timer==1) {
		for (y=ClearLines[z]+z; y>0; y--) {
			for (x=0; x<10; x++) {
				brmap[x][y]=brmap[x][y-1];
			}
		}
		for (x=0; x<10; x++) { //Стираем верхние линии
			brmap[x][0]=FALSE;
		}
		z++;
		if (z<ClearedLines) timer=19;
	}
	
	if (timer==0) { //Анимация закончилась, начисляем очки
		if (ClearedLines==1) score+=100;
		if (ClearedLines==2) score+=300;
		if (ClearedLines==3) score+=700;
		if (ClearedLines==4) score+=1500;
		[self RefreshScore];
		//Всего стерто линий
		TotalClearedLines+=ClearedLines;
		//Если стерли много линий, увеличиваем скорость
		if (TotalClearedLines>19 && speed<15) {
			TotalClearedLines-=20;
			speed++;
			[self RefreshSpeed]; //Обновить дисплей скорости
		}
		ClearedLines=0;
		//Сброс таймера
		timer=tSpeedTable[speed-1];
	}
	LastLineCleared=0;
	//Перерисовка экрана
	[self RefreshScreen];
}

- (void) RefreshScreen { //Перерисовка экрана
	x=0; y=0;
	while (x<10) {
		while (y<20) {
			((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = brmap[x][y];
			y++;
		}
		y=0; x++;
	}
}

- (void) BricksGame { //Игра про кирпичи
	//Удаление предыдущего куска
	x=0; y=0;
	while (x<4) {
		while (y<4) {
			if (tPieces[PrevBrick[0]][PrevBrick[1]][y][x] && YBrickPrev+y>=0)
			{ ((CCSprite *)[BrickMap objectAtIndex:(x+XBrickPrev)+(y+YBrickPrev)*10]).visible = FALSE; }
			y++;
		}
		y=0; x++;
	}
	//Отрисовка текущего куска
	x=0; y=0;
	while (x<4) {
		while (y<4) {
			if (tPieces[CurrentBrick[0]][CurrentBrick[1]][y][x] && YBrick+y>=0)
			{ ((CCSprite *)[BrickMap objectAtIndex:(x+XBrick)+(y+YBrick)*10]).visible = TRUE; }
			y++;
		}
		y=0; x++;
	}
	//Сохраняем раннюю позицию XBrick
	XBrickPrev=XBrick;
	YBrickPrev=YBrick;
	PrevBrick[0]=CurrentBrick[0];
	PrevBrick[1]=CurrentBrick[1];
	//Кнопки влево и вправо
	if (LeftButtonPushed>0 && RightButtonPushed>0) { LeftButtonPushed=0; RightButtonPushed=0; } //Блокировка одновременного нажатия двух кнопок
	if (LeftButtonPushed==1 || (LeftButtonPushed>10 && LeftButtonPushed%4==0)) { XBrick--;
		if (LastSoundPlayed==0)	{ SoundPlay=5; LastSoundPlayed=4; }
	}
	if (RightButtonPushed==1 || (RightButtonPushed>10 && RightButtonPushed%4==0)) { XBrick++;
		if (LastSoundPlayed==0)	{ SoundPlay=5; LastSoundPlayed=4; }
	}
	if (LastSoundPlayed>0) LastSoundPlayed--;
	//Проверка коллизий
	if ([self BricksCheckCollision]==FALSE) {
		if (XBrick>XBrickPrev) XBrick--;
		if (XBrick<XBrickPrev) XBrick++;
		LeftButtonPushed=0; RightButtonPushed=0;
	}
	//Нажата кнопка поворота фигуры
	if (RotateButtonPushed==1) { 
		CurrentBrick[1]++;
		if (CurrentBrick[1]>3) CurrentBrick[1]=0;
		SoundPlay=14;
	}
	//Проверка коллизий
	if ([self BricksCheckCollision]==FALSE) {
		if (RotateButtonPushed==1) { //Пытаемся сместить фигуру в сторону
			XBrick--;
			if ([self BricksCheckCollision]==FALSE) XBrick+=2;
			if ([self BricksCheckCollision]==FALSE) { XBrick--; CurrentBrick[1]=PrevBrick[1];}
		}
	}
	if (DownButtonPushed==1) SoundPlay=5; //Звучит звук падения фигуры
	//Падение блоков
	if (DownButtonPushed>0 && YBrickLastLine==0) {
		YBrick++;
		timer=tSpeedTable[speed-1];
	}
	//Работает таймер
	timer--;
	if (timer<0 && YBrickLastLine==0) { timer=tSpeedTable[speed-1]; YBrick++; }
	//Вторая проверка коллизий
	if (YBrickLastLine>0) YBrick++;
	if ([self BricksCheckCollision]==FALSE) { YBrickLastLine++; YBrick--; } else YBrickLastLine=0;
	if (YBrickLastLine>9) {
		YBrickLastLine=0;
		//Удаление предыдущего куска
		x=0; y=0;
		while (x<4) {
			while (y<4) {
				if (tPieces[PrevBrick[0]][PrevBrick[1]][y][x] && YBrickPrev+y>=0)
				{ ((CCSprite *)[BrickMap objectAtIndex:(x+XBrickPrev)+(y+YBrickPrev)*10]).visible = FALSE; }
				y++;
			}
			y=0; x++;
		}
		//Отрисовка текущего куска
		x=0; y=0;
		while (x<4) {
			while (y<4) {
				if (tPieces[CurrentBrick[0]][CurrentBrick[1]][y][x] && YBrick+y>=0)
				{ ((CCSprite *)[BrickMap objectAtIndex:(x+XBrick)+(y+YBrick)*10]).visible = TRUE;
					brmap[x+XBrick][y+YBrick] = tPieces[CurrentBrick[0]][CurrentBrick[1]][y][x];}
				y++;
			}
			y=0; x++;
		}
		//Задаем новые текущие и следующие куски
		CurrentBrick[0] = NextBrick[0]; //Piece
		CurrentBrick[1] = NextBrick[1]; //Rotate
		NextBrick[0] = arc4random() % 7; //Piece
		NextBrick[1] = arc4random() % 4; //Rotate
		//Обнуляем таймер и координаты
		timer=tSpeedTable[speed-1]; XBrick=3; YBrick=-3; YBrickPrev=-4;
		PrevBrick[0] = 0;
		PrevBrick[1] = 0;
		//Отрисовать следующий кусок
		[self DrawNextPiece];
		//Какие линии будем стирать
		[self CheckClearLines];
		//Блокируем нажатие кнопки вниз, пока она не опущена
		DownButtonPushed = -1;
		//После добавления фигуры проверяем, возможно ли дальше играть или Game Over
		if ([self BricksCheckCollision]==FALSE && ClearedLines==0) { selected=99; timer=160; }
		else if (ClearedLines==0) SoundPlay=6;
	}
	if (mode==2) [self BrickLineTimer];
}

- (void) BrickLineTimer { //Режим 2, в котором через каждые 30 секунд появляется новая линия
	NewBrickLineTimer--;
	if (NewBrickLineTimer == 0) {
		//Сдвигаем линии наверх
		for (y=0; y<19; y++) {
			for (x=0; x<10; x++) {
				brmap[x][y]=brmap[x][y+1];
			}
		}
		//Стираем первую линию
		for (x=0; x<10; x++) {
			brmap[x][19]=FALSE;
		}
		//Рисуем шесть блоков
		for (int k=0; k<6; k++) {
			int m=arc4random() % 10;
			BOOL Check=TRUE;
			while (Check) {
				if (brmap[m][19]) m++;
				else { brmap[m][19]=TRUE; Check=FALSE; }
				if (m>9) m=0;
			}
		}
		NewBrickLineTimer=1859;
		YBrick--; YBrickPrev=-YBrick;
		[self RefreshScreen];
		//Отрисовка текущего куска
		x=0; y=0;
		while (x<4) {
			while (y<4) {
				if (tPieces[CurrentBrick[0]][CurrentBrick[1]][y][x] && YBrick+y>=0)
				{ ((CCSprite *)[BrickMap objectAtIndex:(x+XBrick)+(y+YBrick)*10]).visible = TRUE; }
				y++;
			}
			y=0; x++;
		}
	}
	LastLineCleared++;
	if (LastLineCleared>180) {
		ScoreDisplay.visible = FALSE;
		HiScoreDisplay.visible = FALSE;
		if ([self isPad]) {
			[(CCSprite *)[ScoreMap objectAtIndex:0] setTextureRect:CGRectMake(220, 0, 22, 40)];
			[(CCSprite *)[ScoreMap objectAtIndex:1] setTextureRect:CGRectMake((NewBrickLineTimer/600%10)*22, 0, 22, 40)];
			[(CCSprite *)[ScoreMap objectAtIndex:2] setTextureRect:CGRectMake((NewBrickLineTimer/60%10)*22, 0, 22, 40)];
			[(CCSprite *)[ScoreMap objectAtIndex:3] setTextureRect:CGRectMake(220, 0, 22, 40)];
			[(CCSprite *)[ScoreMap objectAtIndex:4] setTextureRect:CGRectMake(242, 0, 22, 40)];
			[(CCSprite *)[ScoreMap objectAtIndex:5] setTextureRect:CGRectMake(242, 0, 22, 40)];
		} else {
			[(CCSprite *)[ScoreMap objectAtIndex:0] setTextureRect:CGRectMake(110, 0, 11, 20)];
			[(CCSprite *)[ScoreMap objectAtIndex:1] setTextureRect:CGRectMake((NewBrickLineTimer/600%10)*11, 0, 11, 20)];
			[(CCSprite *)[ScoreMap objectAtIndex:2] setTextureRect:CGRectMake((NewBrickLineTimer/60%10)*11, 0, 11, 20)];
			[(CCSprite *)[ScoreMap objectAtIndex:3] setTextureRect:CGRectMake(110, 0, 11, 20)];
			[(CCSprite *)[ScoreMap objectAtIndex:4] setTextureRect:CGRectMake(121, 0, 11, 20)];
			[(CCSprite *)[ScoreMap objectAtIndex:5] setTextureRect:CGRectMake(121, 0, 11, 20)];
		}
	}
}

- (void) SnakeGame { //Игра про змейку
	if (SnakeMusic>0) SnakeMusic--;
	//Стираем карту или рисуем карту со змейкой
	if (level==1) [self ClearMap]; else [self DrawSnakeMap];
	//Блокировка одновременного нажатия кнопок
	if ((LeftButtonPushed>0 && RightButtonPushed>0) || (LeftButtonPushed>0 && UpButtonPushed>0) || (LeftButtonPushed>0 && DownButtonPushed>0)
		|| (RightButtonPushed>0 && UpButtonPushed>0) || (RightButtonPushed>0 && DownButtonPushed>0) || (DownButtonPushed>0 && UpButtonPushed>0))
	{ LeftButtonPushed=0; RightButtonPushed=0; UpButtonPushed=0; DownButtonPushed=0; }
	PrevSnakeMoving=SnakeMoving;
	PrevSCoords[0]=sCoords[0][0];
	PrevSCoords[1]=sCoords[0][1];
	BOOL ControlButtonPushed=FALSE;
	//Двигаем змейку
	if (LeftButtonPushed==1 || (LeftButtonPushed>10 && LeftButtonPushed%4==0)) {
		sCoords[0][0]--; //Перемещаем первый пиксель
		SnakeMoving=1; ControlButtonPushed=TRUE;
	}
	if (RightButtonPushed==1 || (RightButtonPushed>10 && RightButtonPushed%4==0)) {
		sCoords[0][0]++; //Перемещаем первый пиксель
		SnakeMoving=2; ControlButtonPushed=TRUE;
	}
	if (UpButtonPushed==1 || (UpButtonPushed>10 && UpButtonPushed%4==0)) {
		sCoords[0][1]--; //Перемещаем первый пиксель
		SnakeMoving=3; ControlButtonPushed=TRUE;
	}
	if (DownButtonPushed==1 || (DownButtonPushed>10 && DownButtonPushed%4==0)) {
		sCoords[0][1]++; //Перемещаем первый пиксель
		SnakeMoving=4; ControlButtonPushed=TRUE;
	}
	//В режиме 3 и 4 змейка может ходить через границы
	if (mode>2) {
		if (sCoords[0][0]<0) sCoords[0][0]=9;
		if (sCoords[0][0]>9) sCoords[0][0]=0;
		if (sCoords[0][1]<0) sCoords[0][1]=19;
		if (sCoords[0][1]>19) sCoords[0][1]=0;
	}
	if (ControlButtonPushed) {
		if (sCoords[0][0]==sCoords[1][0] && sCoords[0][1]==sCoords[1][1]) {
			SnakeMoving=PrevSnakeMoving;
			sCoords[0][0]=PrevSCoords[0];
			sCoords[0][1]=PrevSCoords[1]; }
		else {
			sCoords[0][0]=PrevSCoords[0];
			sCoords[0][1]=PrevSCoords[1];
			//Смещаем пиксели
			for (int i=SnakeLength; i>0; i--) { sCoords[i][0]=sCoords[i-1][0]; sCoords[i][1]=sCoords[i-1][1]; }
			if (SnakeMoving==1) sCoords[0][0]--;
			if (SnakeMoving==2) sCoords[0][0]++;
			if (SnakeMoving==3) sCoords[0][1]--;
			if (SnakeMoving==4) sCoords[0][1]++;
			timer=sSpeedTable[speed-1];
			if (SnakeMusic==0) SoundPlay=14;
		}
	}
	if (SnakeMoving>0) { //Змейка двигается
		timer--;
		if (timer==0) {
			timer=sSpeedTable[speed-1];
			//Смещаем пиксели
			for (int i=SnakeLength; i>0; i--) { sCoords[i][0]=sCoords[i-1][0]; sCoords[i][1]=sCoords[i-1][1]; }
			if (SnakeMoving==1) sCoords[0][0]--;
			if (SnakeMoving==2) sCoords[0][0]++;
			if (SnakeMoving==3) sCoords[0][1]--;
			if (SnakeMoving==4) sCoords[0][1]++;
		}
	}
	//В режиме 3 и 4 змейка может ходить через границы
	if (mode>2) {
		if (sCoords[0][0]<0) sCoords[0][0]=9;
		if (sCoords[0][0]>9) sCoords[0][0]=0;
		if (sCoords[0][1]<0) sCoords[0][1]=19;
		if (sCoords[0][1]>19) sCoords[0][1]=0;
	}
	if (sCoords[0][0]==sCoords[17][0] && sCoords[0][1]==sCoords[17][1]) { //Змейка съела точку
		SnakeLength++; //Увеличиваем длину змейки
		score+=100; //Прибавляем 100 очков
		[self RefreshScore]; //Обновляем количество очков
		[self RandomizeSnakeDot]; //Генерируем новую точку
		SoundPlay=15;
		SnakeMusic=50;
	}
	[self DrawSnake]; //Рисование змейки
	//Проверка коллизий
	for (int i=1; i<SnakeLength; i++) {
		//Змейка столкнулась с собой
		if (sCoords[0][0]==sCoords[i][0] && sCoords[0][1]==sCoords[i][1]) {DeathDetected=TRUE;}
	}
	//Змейка столкнулась с границами
	if (sCoords[0][0]<0 || sCoords[0][0]>9 || sCoords[0][1]<0 || sCoords[0][1]>19) {DeathDetected=TRUE;}
	//Змейка столкнулась с ячейками карты
	if (brmap[sCoords[0][0]][sCoords[0][1]]) {DeathDetected=TRUE;}
	if (DeathDetected) { timer=150; DeathX=sCoords[0][0]; DeathY=sCoords[0][1]-4; }
	if (SnakeLength>16) { //Длина змейки достаточная
		LevelComplete=TRUE; timer=80;
	}
}

- (void) DrawSnakeMap { //Рисуем карту для змейки
	x=0; y=0;
	while (x<10) {
		while (y<20) {
			((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = snakeMaps[level-2][y][x];
			brmap[x][y]=snakeMaps[level-2][y][x];
			y++;
		}
		y=0; x++;
	}
}

- (void) DrawSnake { //Рисуем змейку
	if (Flick) Flick = FALSE; else Flick = TRUE; //Мерцание
	for (int i=0; i<SnakeLength; i++) {
		if (sCoords[i][0]>-1 && sCoords[i][0]<10 && sCoords[i][1]>-1 && sCoords[i][1]<20) {
			if (i==0) ((CCSprite *)[BrickMap objectAtIndex:sCoords[i][0]+sCoords[i][1]*10]).visible = Flick; //Первый пиксель мерцает
			else ((CCSprite *)[BrickMap objectAtIndex:sCoords[i][0]+sCoords[i][1]*10]).visible = TRUE; //Другие нет
		}
	}
	//Пиксель, который надо съесть
	((CCSprite *)[BrickMap objectAtIndex:sCoords[17][0]+sCoords[17][1]*10]).visible = Flick;
}

- (void) RandomizeSnakeDot {
	BOOL Check = TRUE;
	sCoords[17][0]=arc4random() % 10; sCoords[17][1]=arc4random() % 20; //Генерация координат
	while (Check) {
		Check = FALSE;
		for (int i=0; i<SnakeLength; i++) {
			if (sCoords[i][0] == sCoords[17][0] && sCoords[i][1] == sCoords[17][1]) { //Такая точка уже занята змейкой
				Check = TRUE;
				sCoords[17][0]++;
				if (sCoords[17][0]>9) { sCoords[17][0]=0; sCoords[17][1]++; }
				if (sCoords[17][1]>19) sCoords[17][1]=0;
			}
			if (brmap[sCoords[17][0]][sCoords[17][1]]) { //Такая точка уже занята картой
				Check = TRUE;
				sCoords[17][0]++;
				if (sCoords[17][0]>9) { sCoords[17][0]=0; sCoords[17][1]++; }
				if (sCoords[17][1]>19) sCoords[17][1]=0;
			}
		}
	}
}

- (void) RacingGame { //Гонка
	[self ClearMap];
	//Анимация движущейся трассы
	for (int i=0; i<20; i++) {
		if ((RacingTrackAnimation+i)%5>1) {
			if (mode==1) ((CCSprite *)[BrickMap objectAtIndex:i*10]).visible = TRUE;
			((CCSprite *)[BrickMap objectAtIndex:9+i*10]).visible = TRUE;
		}
	}
	//Кнопки
	if (LeftButtonPushed==1 && CarPosition[0][0]>0) CarPosition[0][0]--;
	if (RightButtonPushed==1 && ((CarPosition[0][0]<1 && mode==1) || (CarPosition[0][0]<2 && mode==2))) CarPosition[0][0]++;
	if (RotateButtonPushed>0 && RotateButtonPushed%2==1) { timer=1; score+=5; [self RefreshScore]; } //Ускоряем машину
	for (int i=0; i<4; i++) { //Рисуем машины
		for (int j=0; j<3; j++) {
			for (int k=0; k<4; k++) {
				if (k+CarPosition[i][1]>-1 && k+CarPosition[i][1]<20) {
					if (mode==1) ((CCSprite *)[BrickMap objectAtIndex:(j+2+CarPosition[i][0]*3)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
					if (mode==2) {
						if (i==0) {
							((CCSprite *)[BrickMap objectAtIndex:(j+CarPosition[i][0]*3)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
						} else {
							//Первая машина
							if (CarPosition[i][0]%2==0) ((CCSprite *)[BrickMap objectAtIndex:j+(k+CarPosition[i][1])*10]).visible = Car[k][j];
							//Вторая машина
							if (CarPosition[i][0]%4==1 || CarPosition[i][0]%4==2) ((CCSprite *)[BrickMap objectAtIndex:(j+3)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
							//Третья машина
							if (CarPosition[i][0]>2) ((CCSprite *)[BrickMap objectAtIndex:(j+6)+(k+CarPosition[i][1])*10]).visible = Car[k][j];
						}
					}
				}
			}
		}
	}
	//Таймер
	timer--;
	if (timer<0) { timer=rSpeedTable[speed-1];
		SoundPlay=14;
		RacingTrackAnimation--;
		if (RacingTrackAnimation<0) RacingTrackAnimation=4;
		for (int i=1; i<4; i++) { //Сдвигаем машины
			CarPosition[i][1]++;
			if (CarPosition[i][1]>20) {
				if (mode==1) { CarPosition[i][0]=arc4random()%2; CarPosition[i][1]=-6; } //Генерируем новые координаты машины
				if (mode==2) { CarPosition[i][0]=arc4random()%6; CarPosition[i][1]=-9; }
				score+=100; [self RefreshScore]; //Прибавляем очки
				CarsLeft--; //Уменьшаем количество оставшихся машин
			}
		}
	}
	//Коллизии
	for (int i=1; i<4; i++) {
		if (mode==1) {
			if (CarPosition[i][0]==CarPosition[0][0] && CarPosition[i][1]>CarPosition[0][1]-4 && CarPosition[i][1]<CarPosition[0][1]+4) {
				DeathDetected=TRUE; timer=150; DeathY=15;
				if (CarPosition[0][0]==0) DeathX=1;
				if (CarPosition[0][0]==1) DeathX=4;
			}
		}
		if (mode==2) {
			if (CarPosition[i][1]>CarPosition[0][1]-4 && CarPosition[i][1]<CarPosition[0][1]+4) {
				if ((CarPosition[i][0]%2==0 && CarPosition[0][0]==0) || //Первая машина
					((CarPosition[i][0]%4==1 || CarPosition[i][0]%4==2) && CarPosition[0][0]==1) || //Вторая машина
					(CarPosition[i][0]>2 && CarPosition[0][0]==2)) /*Третья машина*/ {
						DeathDetected=TRUE; timer=150; DeathY=15;
						if (CarPosition[0][0]==0) DeathX=0;
						if (CarPosition[0][0]==1) DeathX=2;
						if (CarPosition[0][0]==2) DeathX=5;
				}
			}
		}
	}
	if (CarsLeft<1) { LevelComplete=TRUE; timer=80; }
}

- (void) ShooterGame {
	//Таймер
	timer--;
	if (timer<0) {
		timer=spSpeedTable[speed-1];
		//Сдвигаем другие фигуры
		for (int i=18; i>0; i--) {
			for (int j=0; j<10; j++) {
				brmap[j][i]=brmap[j][i-1];
			}
		}
		//Стираем первую линию
		for (int j=0; j<10; j++) {
			brmap[j][0]=FALSE;
		}
		//Рисуем первую линию
		for (int k=0; k<(1+arc4random() % 9); k++) { //От 1-й до 9-ти точек
			int m=arc4random() % 10;
			BOOL Check=TRUE;
			while (Check) {
				if (brmap[m][0]) m++;
				else { brmap[m][0]=TRUE; Check=FALSE; }
				if (m>9) m=0;
			}
		}
	}
	//Перерисовка экрана
	[self RefreshScreen];
	//Кнопки влево и вправо
	if (LeftButtonPushed>0 && RightButtonPushed>0) { LeftButtonPushed=0; RightButtonPushed=0; } //Блокировка одновременного нажатия двух кнопок
	if (LeftButtonPushed==1 || (LeftButtonPushed>10 && LeftButtonPushed%4==0)) { XBrick--; SoundPlay=5; }
	if (RightButtonPushed==1 || (RightButtonPushed>10 && RightButtonPushed%4==0)) { XBrick++; SoundPlay=5; }
	if (XBrick<0) XBrick=0; if (XBrick>9) XBrick=9;
	//Кнопка выстрела
	if (RotateButtonPushed==1 || (RotateButtonPushed>10 && RotateButtonPushed%spFireRate[speed-1]==0)) {
		SoundPlay=6;
		int MaxBullets;
		if (mode==1) MaxBullets=4;
		if (mode==2) MaxBullets=3;
		//Перебираем пули
		for (int i=0; i<MaxBullets; i++) {
			//Если пуля свободна, используем
			if (Bullets[i][1]==-1 && mode==1) {
				Bullets[i][0]=XBrick;
				Bullets[i][1]=17;
				i=4;
			}
			//В режиме 2 используем сразу две пули
			if (Bullets[i*2][1]==-1 && Bullets[i*2+1][1]==-1 && mode==2) {
				if (XBrick>0) { Bullets[i*2][0]=XBrick-1; Bullets[i*2][1]=17; }
				if (XBrick<9) { Bullets[i*2+1][0]=XBrick+1; Bullets[i*2+1][1]=17; }
				i=4;
			}
		}
	}
	for (int i=0; i<6; i++) { //Перебираем пули
		if (Bullets[i][1]>-1) {
			((CCSprite *)[BrickMap objectAtIndex:Bullets[i][0]+Bullets[i][1]*10]).visible = TRUE; //Рисуем пули
			if (brmap[Bullets[i][0]][Bullets[i][1]]) { //Если пуля задела ячейку карты
				brmap[Bullets[i][0]][Bullets[i][1]]=FALSE; Bullets[i][1]=-1; score+=100; DestroyedInvaders++; [self RefreshScore];
			} else if (brmap[Bullets[i][0]][Bullets[i][1]+1]) { //Если пуля задела ячейку карты
				brmap[Bullets[i][0]][Bullets[i][1]+1]=FALSE; Bullets[i][1]=-1; score+=100; DestroyedInvaders++; [self RefreshScore];
			} else Bullets[i][1]--; //Иначе пуля летит вверх
		}
	}
	if (DestroyedInvaders>199 && speed<15) {DestroyedInvaders-=200; speed++; [self RefreshSpeed];} //Уничтожено 200 врагов
	//Рисуем главного игрока
	((CCSprite *)[BrickMap objectAtIndex:180+XBrick]).visible = TRUE;
	((CCSprite *)[BrickMap objectAtIndex:190+XBrick]).visible = TRUE;
	if (XBrick>0) ((CCSprite *)[BrickMap objectAtIndex:190+XBrick-1]).visible = TRUE;
	if (XBrick<9) ((CCSprite *)[BrickMap objectAtIndex:190+XBrick+1]).visible = TRUE;
	//Смотрим предпоследнюю линию
	for (int j=0; j<10; j++) {
		if (brmap[j][18]) DeathDetected=TRUE;
	}
	//Смерть
	if (DeathDetected) {timer=150; DeathY=15; DeathX=XBrick-1;}
}

- (void) TanksGame {
	x=0; y=0;
	while (x<10) {
		while (y<20) {
			if (trmap[x][y]==9) {((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = TRUE;}
			else { ((CCSprite *)[BrickMap objectAtIndex:x+y*10]).visible = FALSE; trmap[x][y]=0; }
			y++;
		}
		y=0; x++;
	} //Стираем карту
	//Рисуем вражеские танки
	for (int i=1; i<4; i++) {
		for (int j=0; j<3; j++) {
			for (int k=0; k<3; k++) {
				if (TanksPosition[i][1]>-1 && TanksPosition[i][1]<20 && Tanks[1][TanksPosition[i][2]][k][j]) {
					trmap[j+TanksPosition[i][0]][k+TanksPosition[i][1]] = i+1;
				}
			}
		}
	}
	//Блокировка одновременного нажатия кнопок
	if ((LeftButtonPushed>0 && RightButtonPushed>0) || (LeftButtonPushed>0 && UpButtonPushed>0) || (LeftButtonPushed>0 && DownButtonPushed>0)
		|| (RightButtonPushed>0 && UpButtonPushed>0) || (RightButtonPushed>0 && DownButtonPushed>0) || (DownButtonPushed>0 && UpButtonPushed>0))
	{ LeftButtonPushed=0; RightButtonPushed=0; UpButtonPushed=0; DownButtonPushed=0; }
	int PrevTankPosition=TanksPosition[0][2];
	//Двигаем танк
	if (LeftButtonPushed==1 || (LeftButtonPushed>10 && LeftButtonPushed%4==0)) {
		if (TanksPosition[0][2]!=0) { TanksPosition[0][2]=0;
			if ([self TanksCheckCollision:0]==FALSE) {
				if (TanksPosition[0][0]>0) { TanksPosition[0][0]--;
					if ([self TanksCheckCollision:0]==FALSE) { TanksPosition[0][0]++; TanksPosition[0][2]=PrevTankPosition;}
				}
				else TanksPosition[0][2]=PrevTankPosition;
			}
		}
		else if (TanksPosition[0][0]>0) { TanksPosition[0][0]--;
			if ([self TanksCheckCollision:0]==FALSE) TanksPosition[0][0]++;
		}
	}
	if (RightButtonPushed==1 || (RightButtonPushed>10 && RightButtonPushed%4==0)) {
		if (TanksPosition[0][2]!=1) { TanksPosition[0][2]=1;
			if ([self TanksCheckCollision:0]==FALSE) {
				if (TanksPosition[0][0]<7) { TanksPosition[0][0]++;
					if ([self TanksCheckCollision:0]==FALSE) { TanksPosition[0][0]--; TanksPosition[0][2]=PrevTankPosition;}
				}
				else TanksPosition[0][2]=PrevTankPosition;
			}			
		}
		else if (TanksPosition[0][0]<7) { TanksPosition[0][0]++;
			if ([self TanksCheckCollision:0]==FALSE) TanksPosition[0][0]--;
		}
	}
	if (UpButtonPushed==1 || (UpButtonPushed>10 && UpButtonPushed%4==0)) {
		if (TanksPosition[0][2]!=2) { TanksPosition[0][2]=2;
			if ([self TanksCheckCollision:0]==FALSE) {
				if (TanksPosition[0][1]>0) { TanksPosition[0][1]--;
					if ([self TanksCheckCollision:0]==FALSE) { TanksPosition[0][1]++; TanksPosition[0][2]=PrevTankPosition;}
				}
				else TanksPosition[0][2]=PrevTankPosition;
			}
		}
		else if (TanksPosition[0][1]>0) { TanksPosition[0][1]--;
			if ([self TanksCheckCollision:0]==FALSE) TanksPosition[0][1]++;
		}
	}
	if (DownButtonPushed==1 || (DownButtonPushed>10 && DownButtonPushed%4==0)) {
		if (TanksPosition[0][2]!=3) { TanksPosition[0][2]=3;
			if ([self TanksCheckCollision:0]==FALSE) {
				if (TanksPosition[0][1]<17) { TanksPosition[0][1]++;
					if ([self TanksCheckCollision:0]==FALSE) { TanksPosition[0][1]--; TanksPosition[0][2]=PrevTankPosition;}
				}
				else TanksPosition[0][2]=PrevTankPosition;
			}
		}
		else if (TanksPosition[0][1]<17) { TanksPosition[0][1]++;
			if ([self TanksCheckCollision:0]==FALSE) TanksPosition[0][1]--;
		}
	}
	if (RotateButtonPushed==1 || (RotateButtonPushed>20 && RotateButtonPushed%8==0)) { //Выстрел
		for (int i=0; i<4; i++) {
			if (TanksBullets[i][2]==4) { //Опрос пуль
				if (TanksPosition[0][2]==0) { TanksBullets[i][0]=TanksPosition[0][0]-1; TanksBullets[i][1]=TanksPosition[0][1]+1; }
				if (TanksPosition[0][2]==1) { TanksBullets[i][0]=TanksPosition[0][0]+3; TanksBullets[i][1]=TanksPosition[0][1]+1; }
				if (TanksPosition[0][2]==2) { TanksBullets[i][0]=TanksPosition[0][0]+1; TanksBullets[i][1]=TanksPosition[0][1]-1; }
				if (TanksPosition[0][2]==3) { TanksBullets[i][0]=TanksPosition[0][0]+1; TanksBullets[i][1]=TanksPosition[0][1]+3; }
				TanksBullets[i][2] = TanksPosition[0][2];
				i=4;
				SoundPlay=5;
			}
		}
	}
	//Рисуем танк игрока на карте
	for (int j=0; j<3; j++) {
		for (int k=0; k<3; k++) {
			if (TanksPosition[0][1]>-1 && TanksPosition[0][1]<20 && Tanks[0][TanksPosition[0][2]][k][j]) {
				trmap[j+TanksPosition[0][0]][k+TanksPosition[0][1]] = 1;
			}
		}
	}
	//Рисуем пули
	BulletTime--;
	if (BulletTime<0) BulletTime=3;
	for (int i=0; i<16; i++) {
		for (int j=0; j<16; j++) {
			if (TanksBullets[i][0]==TanksBullets[j][0] && TanksBullets[i][1]==TanksBullets[j][1] && TanksBullets[i][2]<4 && TanksBullets[j][2]<4 && i!=j) {
				TanksBullets[i][2]=4; TanksBullets[j][2]=4; //Пуля столкнулась с другой пулей
			}
		}
		if (TanksBullets[i][0]>-1 && TanksBullets[i][0]<10 && TanksBullets[i][1]>-1 && TanksBullets[i][1]<20 && TanksBullets[i][2]<4) {
			if (trmap[TanksBullets[i][0]][TanksBullets[i][1]]>1 && trmap[TanksBullets[i][0]][TanksBullets[i][1]]<5 && i<4) {
				score+=100;
				DestroyedInvaders++;
				[self RefreshScore];
				int KilledTank=trmap[TanksBullets[i][0]][TanksBullets[i][1]];
				TanksPosition[KilledTank-1][1]-=20;
				TanksBullets[i][2]=4;
				SoundPlay=6;
			}
			else if (trmap[TanksBullets[i][0]][TanksBullets[i][1]]==1 && i>3) {
				DeathDetected=TRUE;
				//Смерть
			}
			else if (trmap[TanksBullets[i][0]][TanksBullets[i][1]]>0) {
				TanksBullets[i][2]=4;
				if (trmap[TanksBullets[i][0]][TanksBullets[i][1]]==9) trmap[TanksBullets[i][0]][TanksBullets[i][1]]=0;
			}
			else ((CCSprite *)[BrickMap objectAtIndex:(TanksBullets[i][0])+(TanksBullets[i][1])*10]).visible = TRUE;
		} else { TanksBullets[i][2]=4; } //Признаем пулю недействительной
		if (BulletTime==0 && TanksBullets[i][2]<4) { //Двигаем пулю
			if (TanksBullets[i][2]==0) TanksBullets[i][0]--;
			if (TanksBullets[i][2]==1) TanksBullets[i][0]++;
			if (TanksBullets[i][2]==2) TanksBullets[i][1]--;
			if (TanksBullets[i][2]==3) TanksBullets[i][1]++;
		}
	}
	//Ходят вражеские танки
	timer--;
	if (timer<0) { timer=tSpeedTable[speed-1];
		//Опрос танка
		if (TanksPosition[EnemyTankMove][1]<0) { //Если танка нет
			//Определяем ему рандомное местоположение
			int TankRandom = arc4random()%6; BOOL Check = TRUE;
			while (Check) {
				switch (TankRandom) {
					case 0:	TanksPosition[EnemyTankMove][0]=0; TanksPosition[EnemyTankMove][1]=0;
							TanksPosition[EnemyTankMove][2]=arc4random()%4;
							if ([self TanksCheckCollision:EnemyTankMove]) Check=FALSE;
						break;
					case 1:	TanksPosition[EnemyTankMove][0]=7; TanksPosition[EnemyTankMove][1]=0;
							TanksPosition[EnemyTankMove][2]=arc4random()%4;
							if ([self TanksCheckCollision:EnemyTankMove]) Check=FALSE;
						break;
					case 2:	TanksPosition[EnemyTankMove][0]=0; TanksPosition[EnemyTankMove][1]=8;
							TanksPosition[EnemyTankMove][2]=arc4random()%4;
							if ([self TanksCheckCollision:EnemyTankMove]) Check=FALSE;
						break;
					case 3:	TanksPosition[EnemyTankMove][0]=7; TanksPosition[EnemyTankMove][1]=8;
							TanksPosition[EnemyTankMove][2]=arc4random()%4;
							if ([self TanksCheckCollision:EnemyTankMove]) Check=FALSE;
						break;
					case 4:	TanksPosition[EnemyTankMove][0]=0; TanksPosition[EnemyTankMove][1]=17;
							TanksPosition[EnemyTankMove][2]=arc4random()%4; 
							if ([self TanksCheckCollision:EnemyTankMove]) Check=FALSE;
						break;
					case 5:	TanksPosition[EnemyTankMove][0]=7; TanksPosition[EnemyTankMove][1]=17;
							TanksPosition[EnemyTankMove][2]=arc4random()%4;
							if ([self TanksCheckCollision:EnemyTankMove]) Check=FALSE;
						break;
				}
				TankRandom++; if (TankRandom>5) TankRandom=0;
			}
		} else {
			int TankRandom = arc4random()%12;
			BOOL TankMoving = TRUE;
			PrevTankPosition=TanksPosition[EnemyTankMove][2];
			//Поворачивается вражеский танк
			switch (TankRandom) {
				case 0: if (TanksPosition[EnemyTankMove][2]!=0) { TanksPosition[EnemyTankMove][2]=0; TankMoving = FALSE; } break;
				case 1: if (TanksPosition[EnemyTankMove][2]!=1) { TanksPosition[EnemyTankMove][2]=1; TankMoving = FALSE; } break;
				case 2: if (TanksPosition[EnemyTankMove][2]!=2) { TanksPosition[EnemyTankMove][2]=2; TankMoving = FALSE; } break;
				case 3: if (TanksPosition[EnemyTankMove][2]!=3) { TanksPosition[EnemyTankMove][2]=3; TankMoving = FALSE; } break;
				case 4: case 5: case 6: case 7: 
					if (abs(TanksPosition[EnemyTankMove][0]-TanksPosition[0][0])>=abs(TanksPosition[EnemyTankMove][1]-TanksPosition[0][1])) {
						if (TanksPosition[EnemyTankMove][0]>TanksPosition[0][0] && TanksPosition[EnemyTankMove][2]!=0)
						{ TanksPosition[EnemyTankMove][2]=0; TankMoving = FALSE; }
						else if (TanksPosition[EnemyTankMove][0]<TanksPosition[0][0] && TanksPosition[EnemyTankMove][2]!=1)
						{ TanksPosition[EnemyTankMove][2]=1; TankMoving = FALSE; }
					} else {
							if (TanksPosition[EnemyTankMove][1]>TanksPosition[0][1] && TanksPosition[EnemyTankMove][2]!=2)
							{ TanksPosition[EnemyTankMove][2]=2; TankMoving = FALSE; }
							else if (TanksPosition[EnemyTankMove][1]<TanksPosition[0][1] && TanksPosition[EnemyTankMove][2]!=3)
							{ TanksPosition[EnemyTankMove][2]=3; TankMoving = FALSE; }
					} break;
			}
			if ([self TanksCheckCollision:EnemyTankMove]==FALSE) {
				BOOL Check=TRUE;
				if (TanksPosition[EnemyTankMove][0]>0 && TanksPosition[EnemyTankMove][2]==0) {
					TanksPosition[EnemyTankMove][0]--; Check=FALSE;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE)
						{ TanksPosition[EnemyTankMove][0]++; Check=TRUE;}
				}
				if (TanksPosition[EnemyTankMove][0]<7 && TanksPosition[EnemyTankMove][2]==1) {
					TanksPosition[EnemyTankMove][0]++; Check=FALSE;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE)
					{ TanksPosition[EnemyTankMove][0]--; Check=TRUE;}
				}
				if (TanksPosition[EnemyTankMove][1]>0 && TanksPosition[EnemyTankMove][2]==2) {
					TanksPosition[EnemyTankMove][1]--; Check=FALSE;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE)
					{ TanksPosition[EnemyTankMove][1]++; Check=TRUE;}
				}
				if (TanksPosition[EnemyTankMove][1]<17 && TanksPosition[EnemyTankMove][2]==3) {
					TanksPosition[EnemyTankMove][1]++; Check=FALSE;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE)
					{ TanksPosition[EnemyTankMove][1]--; Check=TRUE;}
				}
				if (Check) {
					TanksPosition[EnemyTankMove][2]=PrevTankPosition;
					TankMoving=TRUE;
				}
			}
			//Двигается вражеский танк
			if (TankMoving) {
				if (TanksPosition[EnemyTankMove][0]>0 && TanksPosition[EnemyTankMove][2]==0) { TanksPosition[EnemyTankMove][0]--;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE) TanksPosition[EnemyTankMove][0]++;	}
				if (TanksPosition[EnemyTankMove][0]<7 && TanksPosition[EnemyTankMove][2]==1) { TanksPosition[EnemyTankMove][0]++;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE) TanksPosition[EnemyTankMove][0]--;	}
				if (TanksPosition[EnemyTankMove][1]>0 && TanksPosition[EnemyTankMove][2]==2) { TanksPosition[EnemyTankMove][1]--;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE) TanksPosition[EnemyTankMove][1]++;	}
				if (TanksPosition[EnemyTankMove][1]<17 && TanksPosition[EnemyTankMove][2]==3) { TanksPosition[EnemyTankMove][1]++;
					if ([self TanksCheckCollision:EnemyTankMove]==FALSE) TanksPosition[EnemyTankMove][1]--;	}
			}
			//Стреляет вражеский танк
			for (int i=EnemyTankMove*4; i<(4+EnemyTankMove*4); i++) {
				if (TanksBullets[i][2]==4) { //Опрос пуль
					if (TanksPosition[EnemyTankMove][2]==0) { TanksBullets[i][0]=TanksPosition[EnemyTankMove][0]-1; TanksBullets[i][1]=TanksPosition[EnemyTankMove][1]+1; }
					if (TanksPosition[EnemyTankMove][2]==1) { TanksBullets[i][0]=TanksPosition[EnemyTankMove][0]+3; TanksBullets[i][1]=TanksPosition[EnemyTankMove][1]+1; }
					if (TanksPosition[EnemyTankMove][2]==2) { TanksBullets[i][0]=TanksPosition[EnemyTankMove][0]+1; TanksBullets[i][1]=TanksPosition[EnemyTankMove][1]-1; }
					if (TanksPosition[EnemyTankMove][2]==3) { TanksBullets[i][0]=TanksPosition[EnemyTankMove][0]+1; TanksBullets[i][1]=TanksPosition[EnemyTankMove][1]+3; }
					TanksBullets[i][2] = TanksPosition[EnemyTankMove][2];
					i=16;
				}
			}
		}
		//Переключение на следующий танк
		EnemyTankMove++;
		if (EnemyTankMove>3) EnemyTankMove=1;
	}
	//Рисуем танки
	for (int i=0; i<4; i++) {
		for (int j=0; j<3; j++) {
			for (int k=0; k<3; k++) {
				if (i==0) {
					if (TanksPosition[i][1]>-1 && TanksPosition[i][1]<20 && Tanks[0][TanksPosition[i][2]][k][j]) {
						((CCSprite *)[BrickMap objectAtIndex:(j+TanksPosition[i][0])+(k+TanksPosition[i][1])*10]).visible = TRUE;
					}
				} else {
					if (TanksPosition[i][1]>-1 && TanksPosition[i][1]<20 && Tanks[1][TanksPosition[i][2]][k][j]) {
						((CCSprite *)[BrickMap objectAtIndex:(j+TanksPosition[i][0])+(k+TanksPosition[i][1])*10]).visible = TRUE;
					}
				}
			}
		}
	}
	//Смерть
	if (DeathDetected) {timer=150; DeathY=TanksPosition[0][1]-2; DeathX=TanksPosition[0][0];}
	if (DestroyedInvaders>29) { LevelComplete=TRUE; timer=80; }
}

- (void) PauseGame {
	pausetimer--; //Отдельный таймер для паузы
	if (pausetimer>30) PauseIcon.visible = TRUE; else PauseIcon.visible = FALSE; //Мигание значка с паузой
	if (pausetimer==0) pausetimer=60;
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {
	if (buttonIndex == 1) //Reset
	{
		z=0; timer=60; selected=0;
		PauseIcon.visible = FALSE;
		[[SimpleAudioEngine sharedEngine] playBackgroundMusic:@"mr_9999_00.wav" loop:FALSE];
		[self RefreshScore];
		[self InitTitleMap];
		music=0; SoundPlay=0;
		score=0;
	}
}

- (void) nextFrame:(ccTime)dt { //Вызывается каждый кадр
	//Музыка
	if (music>0) music--;
	//Если кнопки не нажаты, сбрасываем их состояния, иначе увеличиваем их
	if (music==0 || game==1) {
		if (Button2.active) StartButtonPushed++; else StartButtonPushed=0;
		if (ButtonLeft.active) LeftButtonPushed++; else LeftButtonPushed=0;
		if (ButtonRight.active) RightButtonPushed++; else RightButtonPushed=0;
		if (ButtonDown.active && DownButtonPushed>-1) DownButtonPushed++;
		if (ButtonDown.active==FALSE) DownButtonPushed=0;
		if (ButtonUp.active) UpButtonPushed++; else UpButtonPushed=0;
		if (ButtonRotate.active) RotateButtonPushed++; else RotateButtonPushed=0; }
	//Менюшки и запуск игры
	if (selected==0) [self BrickGameTitle]; 
	if (selected==1) [self MainMenu];
	//Тетрис
	if (selected==2) {
		if (ClearedLines>0) [self ClearingLines]; //Стираем линии
		else [self BricksGame]; //Собственно тетрис
	}
	//Другие игры
	if (selected>2 && selected<41) {
		if (music==119) { [self BeginGameMusic]; //Музыка начала игры
			if (selected==3) [self SnakeGame]; //Собственно змейка
			else if (selected==4) [self RacingGame]; //Собственно гонка
			else if (selected==5) [self ShooterGame]; //Собственно шутер
			else if (selected==6) [self TanksGame]; //Собственно танки
		} else if (music>0) [self BeginGameMusic]; //Музыка начала игры
		else if (DeathDetected) [self DeathAnimation]; //Анимация смерти
		else if (LevelComplete) [self LevelUp]; //Анимация перехода на следующий уровень
		else if (selected==3) [self SnakeGame]; //Собственно змейка
		else if (selected==4) [self RacingGame]; //Собственно гонка
		else if (selected==5) [self ShooterGame]; //Собственно шутер
		else if (selected==6) [self TanksGame]; //Собственно танки
	}
	//Пауза
	if (selected>40 && selected<80) {
		[self PauseGame];
		if (selected==43) [self DrawSnake]; //Рисуем мерцание змейки
	}
	//Game Over
	if (selected==99) [self GameOver];
	
	//Обработка нажатий кнопок
	if (Button1.active) { //Reset
		UIAlertView *alert = [[UIAlertView alloc] init];
		[alert setTitle:@"Сбросить игру?"];
		[alert setMessage:@"Весь прогресс будет потерян."];
		[alert setDelegate:self];
		[alert addButtonWithTitle:@"Нет"];
		[alert addButtonWithTitle:@"Да"];
		[alert show];
		[alert release];
	}
	//Переход в меню выбора игры
	if (selected==0 && Button2.active) {LetterAnimation=0; MiniAnimation=0; selected=1; StartButtonPushed=2;
		[[SimpleAudioEngine sharedEngine] stopBackgroundMusic]; /*Остановить музыку*/ }
	if (!(DeathDetected) && !(LevelComplete) && (music==0 || game==1)) {
		//Пауза
		if (selected>1 && selected<41 && Button2.active && StartButtonPushed==1) {
			selected+=40; StartButtonPushed=2; pausetimer=60;
			[self RefreshHiScore];
		}
		//Вернуться к игре
		if (selected>40 && selected<80 && Button2.active && StartButtonPushed==1) {
			selected-=40; StartButtonPushed=2; PauseIcon.visible = FALSE;
			[self RefreshScore];
		}
	}
	//Звуки
	if (SoundPlay>0 && music==0) {
		[[SimpleAudioEngine sharedEngine] stopEffect:SoundFX];
		switch (SoundPlay) {
			case 1:
				SoundFX=[[SimpleAudioEngine sharedEngine] playEffect:@"mr_9999_01.wav"];
				[[SimpleAudioEngine sharedEngine] stopBackgroundMusic];
				break;
			case 5:	SoundFX=[[SimpleAudioEngine sharedEngine] playEffect:@"mr_9999_05.wav"];	break;
			case 6:	SoundFX=[[SimpleAudioEngine sharedEngine] playEffect:@"mr_9999_06.wav"];	break;
			case 14:SoundFX=[[SimpleAudioEngine sharedEngine] playEffect:@"mr_9999_14.wav"];	break;
			case 15:SoundFX=[[SimpleAudioEngine sharedEngine] playEffect:@"mr_9999_15.wav"];	break;
			default:
				break;
		}
	}
	SoundPlay=0;
}

//Перерисовка количества очков
- (void) RefreshScore {
	HiScoreDisplay.visible = FALSE;
	ScoreDisplay.visible = TRUE;
	if ([self isPad]) { //Если айпад
		[(CCSprite *)[ScoreMap objectAtIndex:0] setTextureRect:CGRectMake((score/100000%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:1] setTextureRect:CGRectMake((score/10000%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:2] setTextureRect:CGRectMake((score/1000%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:3] setTextureRect:CGRectMake((score/100%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:4] setTextureRect:CGRectMake((score/10%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:5] setTextureRect:CGRectMake((score%10)*22, 0, 22, 40)];
	} else {
		[(CCSprite *)[ScoreMap objectAtIndex:0] setTextureRect:CGRectMake((score/100000%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:1] setTextureRect:CGRectMake((score/10000%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:2] setTextureRect:CGRectMake((score/1000%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:3] setTextureRect:CGRectMake((score/100%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:4] setTextureRect:CGRectMake((score/10%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:5] setTextureRect:CGRectMake((score%10)*11, 0, 11, 20)];
	}
}
//Перерисовка рекорда
- (void) RefreshHiScore {
	HiScoreDisplay.visible = TRUE;
	ScoreDisplay.visible = TRUE;
	if ([self isPad]) { //Если айпад
		[(CCSprite *)[ScoreMap objectAtIndex:0] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/100000%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:1] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/10000%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:2] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/1000%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:3] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/100%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:4] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/10%10)*22, 0, 22, 40)];
		[(CCSprite *)[ScoreMap objectAtIndex:5] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]%10)*22, 0, 22, 40)];
	} else {
		[(CCSprite *)[ScoreMap objectAtIndex:0] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/100000%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:1] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/10000%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:2] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/1000%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:3] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/100%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:4] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]/10%10)*11, 0, 11, 20)];
		[(CCSprite *)[ScoreMap objectAtIndex:5] setTextureRect:CGRectMake((HiScoreRecords[game-1][mode-1]%10)*11, 0, 11, 20)];
	}
}
//Перерисовка текущей скорости
- (void) RefreshSpeed { 
	if ([self isPad]) { //Если айпад
		[(CCSprite *)[SpeedMap objectAtIndex:0] setTextureRect:CGRectMake((speed/10%10)*22, 0, 22, 40)];
		[(CCSprite *)[SpeedMap objectAtIndex:1] setTextureRect:CGRectMake((speed%10)*22, 0, 22, 40)];
	} else {
		[(CCSprite *)[SpeedMap objectAtIndex:0] setTextureRect:CGRectMake((speed/10%10)*11, 0, 11, 20)];
		[(CCSprite *)[SpeedMap objectAtIndex:1] setTextureRect:CGRectMake((speed%10)*11, 0, 11, 20)];
	}
}
//Перерисовка текущего уровня
- (void) RefreshLevel { 
	if ([self isPad]) { //Если айпад
		[(CCSprite *)[LevelMap objectAtIndex:0] setTextureRect:CGRectMake((level/10%10)*22, 0, 22, 40)];
		[(CCSprite *)[LevelMap objectAtIndex:1] setTextureRect:CGRectMake((level%10)*22, 0, 22, 40)];
	} else {
		[(CCSprite *)[LevelMap objectAtIndex:0] setTextureRect:CGRectMake((level/10%10)*11, 0, 11, 20)];
		[(CCSprite *)[LevelMap objectAtIndex:1] setTextureRect:CGRectMake((level%10)*11, 0, 11, 20)];
	}
}
//Перерисовка количества жизней
- (void) RefreshLives {
	for (int i=0; i<4; i++) {
		if (lives>i) ((CCSprite *)[NextMap objectAtIndex:3+i*4]).visible = TRUE; else ((CCSprite *)[NextMap objectAtIndex:3+i*4]).visible = FALSE;
	}
}

- (void) LevelUp { //Переход на новый уровень
	timer--;
	for (x=0; x<10; x++)
	{
		if (timer>41) ((CCSprite *)[BrickMap objectAtIndex:x+10*round((timer-41)/2)]).visible = TRUE;
		else if (timer>1 && timer<39) ((CCSprite *)[BrickMap objectAtIndex:x+10*round((39-timer)/2)]).visible = FALSE;
	}
	if (timer==0) { LevelComplete=FALSE;
		if (game==2 || game==5) level++; //Уровень увеличиваем в змейке
		if (((game==2 || game==5) && mode%2==1) || (game==3)) speed++; //Скорость увеличиваем в режиме змейки 1/3 или в режиме танков 1 или в гонке
		if (level>15) level=1;
		if (speed>15) speed=1;
		if (game==2) [self InitSnakeGame];
		if (game==3) [self InitRacingGame];
		if (game==5) [self InitTanksGame];}
}

- (void) BeginGameMusic { //Остановить игру, пока не прозвучит музыка начала игры
	if (music==119) [[SimpleAudioEngine sharedEngine] playEffect:@"mr_9999_startgame.wav"];
}
		
- (void) DeathAnimation { //Анимация смерти
	timer--;
	if (timer==149) { //Первый фрейм смерти
		[[SimpleAudioEngine sharedEngine] playEffect:@"mr_9999_explode.wav"]; //Звук взрыва
		lives--; [self RefreshLives]; //Отнимаем и обновляем количество жизней
		if (DeathX>5) DeathX=5; if (DeathX<0) DeathX=0;	if (DeathY<0) DeathY=0; if (DeathY>15) DeathY=15;
	}
	if (timer>41) {
		for (int i=0; i<5; i++) {
			for (int j=0; j<5; j++) {
				if (timer%30/2 == 14) 
					((CCSprite *)[BrickMap objectAtIndex:DeathX+i+(DeathY+j)*10]).visible = Death[0][i][j];
				if (timer%30/2 == 13 || timer%30/2 == 0)
					((CCSprite *)[BrickMap objectAtIndex:DeathX+i+(DeathY+j)*10]).visible = Death[1][i][j];
				if (timer%30/2 < 13 && timer%30/2%2 == 1)
					((CCSprite *)[BrickMap objectAtIndex:DeathX+i+(DeathY+j)*10]).visible = Death[2][i][j];
				if (timer%30/2 < 13 && timer%30/2 > 0 && timer%30/2%2 == 0)
					((CCSprite *)[BrickMap objectAtIndex:DeathX+i+(DeathY+j)*10]).visible = Death[3][i][j];
			}
		}
	}
	if (timer<42 && lives>0) {
		for (x=0; x<10; x++)
		{
			if (timer>21) ((CCSprite *)[BrickMap objectAtIndex:x+10*(timer-22)]).visible = TRUE;
			else if (timer>1 && timer<22) ((CCSprite *)[BrickMap objectAtIndex:x+10*(21-timer)]).visible = FALSE;
		}
	}
	if (timer==41 && lives==0) {selected=99; timer=160; DeathDetected=FALSE;}
	if (timer==0) { DeathDetected=FALSE; 
		if (game==2) [self InitSnakeGame];
		if (game==3) [self InitRacingGame];
		if (game==4) [self InitShooterGame];
		if (game==5) [self InitTanksGame];} //Перезапускаем игру
}
//Игра окончена
- (void) GameOver {
	timer--;
	if (timer==159) [[SimpleAudioEngine sharedEngine] playBackgroundMusic:@"mr_9999_00.wav" loop:FALSE];
	for (x=0; x<10; x++)
	{
		if (timer>81) ((CCSprite *)[BrickMap objectAtIndex:x+10*round((timer-81)/4)]).visible = TRUE;
		else if (timer>1 && timer<79) ((CCSprite *)[BrickMap objectAtIndex:x+10*round((79-timer)/4)]).visible = FALSE;
	}
	if (timer==0) { LetterAnimation=0; MiniAnimation=0; selected=1;
		//Проверка, получен ли рекорд
		if (score>HiScoreRecords[game-1][mode-1]) {
			HiScoreRecords[game-1][mode-1]=score;
			//Запись рекорда
			NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
			NSString *docsDir = [dirPaths objectAtIndex:0];
			NSString *file = [docsDir stringByAppendingPathComponent: @"hiscores.dat"];
		
			NSFileManager *filemgr = [NSFileManager defaultManager];
			if ([filemgr fileExistsAtPath:file] == FALSE) {
				[filemgr createFileAtPath:file contents: nil attributes:nil]; }
		
			//get a handle to the file
			NSFileHandle *fileHandle = [NSFileHandle fileHandleForWritingAtPath:file];
		
			for (int i=0; i<5; i++) {
				for (int j=0; j<4; j++) {
					//Записываем рекорды
					NSString *HiScores = [NSString stringWithFormat:@"%i%@", HiScoreRecords[i][j], @"\n"];
					NSData *data = [HiScores dataUsingEncoding: NSASCIIStringEncoding];
					NSData *encryptedData = [data AESEncryptWithPassphrase:@"afuvsbzkrnfahmjg"];
					[fileHandle writeData:encryptedData];
				}
			}
			
			//Закрываем файл
			[fileHandle closeFile];
		}
	}
	[self RefreshScore];
}

// on "dealloc" you need to release all your retained objects
- (void) dealloc
{
	// in case you have something to dealloc, do it in this method
	// in this particular example nothing needs to be released.
	// cocos2d will automatically release all the children (Label)
	
	// don't forget to call "super dealloc"
	[super dealloc];
}
@end
